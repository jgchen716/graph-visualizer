{"version":3,"sources":["components/Results.jsx","algos/bfs.js","algos/bridges.js","algos/clusteringCoefficient.js","algos/dfs.js","algos/dijkstra.js","algos/topoSort.js","algos/triadicClosure.js","components/Graph.jsx","components/Toolbar.jsx","App.js","index.js"],"names":["emptyResults","className","resultsToText","result","algorithm","separator","bfsString","frontierCount","push","forEach","frontier","sort","a","b","currString","node","slice","lastIndexOf","dfsString","dijkstraString","distance","topoString","valid","res","clusteringString","cc","toFixed","bridgesString","size","node1","node2","triadicString","NodeA","NodeB","Results","undefined","bfs","g","start","seen","Set","queue","tempQueue","parent","add","adjList","get","weight","includes","has","length","dfsVisit","time","u","visited","discovered","low","bridges","v","Math","min","values","clusteringIndividual","neighbors","numNeighbors","numPairs","factorial","count","neighborId","neighborId2","weight2","neighborId3","weight3","numEdges","state","undirected","denom","num","i","clusteringCoefficient","dfs","stack","curr","pop","outneighbors","dijkstra","distances","Map","value","set","Number","MAX_VALUE","numIterations","maxSize","minDist","minNode","val","key","delete","color","finished","topoSort","reverse","includesNode","neighborsA","nodeB","included","nodeA","shareNeighbor","neighborsB","shared","neighborA","some","neighborB","triadicClosure","DIM","circleStyle","selected","x","y","padding","margin","position","backgroundColor","borderRadius","border","width","height","lineHeight","left","top","outlineWidth","initialState","props","nextId","selectedId","selectedEdge","selectedType","unweighted","selectedWeight","cleared","results","open","Graph","getClickCoords","event","dim","target","getBoundingClientRect","clientX","clientY","addNode","e","id","nodeToElement","bounds","onDrag","ui","setState","changed","forceUpdate","tabIndex","onKeyDown","removeNode","style","onClick","shiftKey","addEdge","selectNode","filter","outNode","inNode","obj","shouldComponentUpdate","selectedAlgorithm","removeEdge","stopPropagation","bind","nextProps","updated","this","nodes","it","next","done","edges","drawnEdges","neighbor","end","label","showHead","strokeWidth","edgeWeight","parseInt","dottedEdges","drawnDottedEdges","dashness","strokeLen","nonStrokeLen","onDoubleClick","Component","Toolbar","setSelectedType","setSelectedWeight","setSelectedAlgorithm","setCleared","instructionsText","useState","setOpen","handleClose","isDisabled","alg","handleChange","type","console","log","Button","variant","Dialog","onClose","aria-labelledby","aria-describedby","DialogTitle","DialogContent","DialogContentText","DialogActions","autoFocus","disabled","FormControl","component","RadioGroup","aria-label","name","onChange","FormControlLabel","control","Radio","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"yRAEMA,EACJ,sBAAKC,UAAU,UAAf,UACE,oBAAIA,UAAU,kBAAd,qBACA,qBAAKA,UAAU,gBAAf,sDAIEC,EAAgB,SAACC,EAAQC,GAC7B,IAAMC,EAAY,aAClB,OAAQD,GACN,IAAK,MACH,IAAIE,EAAY,GACZC,EAAgB,EAgBpB,OAfAD,EAAUE,KAAV,2BAAmCL,EAAO,GAAG,KAC7CA,EAAOM,SAAQ,SAACC,GACdA,EAAWA,EAASC,MAAK,SAAUC,EAAGC,GACpC,OAAOD,EAAIC,KAEb,IAAIC,EAAU,mBAAeP,IAAf,MACdG,EAASD,SAAQ,SAACM,GAAD,OAAWD,GAAU,cAAWC,EAAX,SACtCD,EAAaA,EAAWE,MAAM,EAAGF,EAAWG,YAAY,MACxDX,EAAUE,KACR,qCACKM,EACH,yBAFQP,OAOZ,2CAEE,uBACCF,EACD,uBACCC,KAGP,IAAK,MACH,IAAIY,EAAY,GAShB,OARAf,EAAOM,SAAQ,SAACM,GAAD,OACbG,EAAUV,KACR,yCACSO,EACP,yBAFQA,OAOZ,2CAEE,uBACCV,EACD,uBAJF,0BAME,uBACCa,KAGP,IAAK,WACH,IAAIC,EAAiB,GASrB,OARAhB,EAAOM,SAAQ,YAAyB,IAAtBM,EAAqB,EAArBA,KAAMK,EAAe,EAAfA,SACtBD,EAAeX,KACb,yCACSO,EADT,KACiBK,EADjB,SAEE,yBAFF,cAAiBL,EAAjB,aAA0BK,EAA1B,eAOF,gDAEE,uBACCf,EACD,uBAJF,+BAK+BF,EAAO,GAAGY,KALzC,IAME,uBACCI,KAGP,IAAK,YACH,IAAIE,EAAa,GAmBjB,OAlBKlB,EAAOmB,OAGVD,EAAWb,KACT,+DAEE,2BAGJL,EAAOoB,IAAId,SAAQ,SAACM,GAClBM,EAAWb,KACT,yCACSO,EACP,yBAFQA,QAVdM,EAAWb,KAAK,gDAkBhB,wDAEE,uBACCH,EACD,uBACCgB,KAGP,IAAK,aACH,IAAIG,EAAmB,GASvB,OARArB,EAAOM,SAAQ,YAAmB,IAAhBM,EAAe,EAAfA,KAAMU,EAAS,EAATA,GACtBD,EAAiBhB,KACf,yCACSO,EADT,KACiBU,EAAGC,QAAQ,GAC1B,yBAFQX,OAOZ,8DAEE,uBACCV,EACD,uBACCmB,KAGP,IAAK,UACH,IAAIG,EAAgB,GAmBpB,OAlBoB,IAAhBxB,EAAOyB,KACTD,EAAcnB,KAAK,6BAEnBmB,EAAcnB,KACZ,kDAEE,2BAGJL,EAAOM,SAAQ,YAAuB,IAApBoB,EAAmB,EAAnBA,MAAOC,EAAY,EAAZA,MACvBH,EAAcnB,KACZ,yCACSqB,EADT,IACiB,MADjB,QAC6BC,EAC3B,yBAFF,cAAiBD,EAAjB,mBAAiCC,SAQrC,sDAEE,uBACCzB,EACD,uBACCsB,KAGP,IAAK,UACH,IAAII,EAAgB,GAwBpB,OAvBoB,IAAhB5B,EAAOyB,KACTG,EAAcvB,KACZ,uFAEE,4BAIJuB,EAAcvB,KACZ,2EAEE,2BAGJL,EAAOM,SAAQ,YAAuB,IAApBuB,EAAmB,EAAnBA,MAAOC,EAAY,EAAZA,MACvBF,EAAcvB,KACZ,yCACSwB,EADT,IACiB,KADjB,QAC4BC,EAC1B,yBAFF,cAAiBD,EAAjB,mBAAiCC,SAQrC,uDAEE,uBACC5B,EACD,uBACC0B,KAGP,QACE,MAAO,KAiBEG,EAbC,SAAC,GAA2B,IAAzB/B,EAAwB,EAAxBA,OAAQC,EAAgB,EAAhBA,UAGzB,YADa+B,IAAXhC,QAAsCgC,IAAd/B,GAAyC,KAAdA,EAEnDJ,EAEA,sBAAKC,UAAU,UAAf,UACE,oBAAIA,UAAU,kBAAd,qBACA,qBAAKA,UAAU,gBAAf,SAAgCC,EAAcC,EAAQC,SC/K7CgC,EA7BH,SAACC,EAAGC,GAOf,IANA,IAAMC,EAAO,IAAIC,IAEbC,EAAQ,CAACH,GAETf,EAAM,GALe,aASxBA,EAAIf,KAAJ,YAAaiC,IACb,IAAIC,EAAY,GAEhBD,EAAMhC,SAAQ,SAACkC,GACdJ,EAAKK,IAAID,MAGVF,EAAMhC,SAAQ,SAACkC,GACdN,EAAEQ,QAAQC,IAAIH,GAAQlC,SAAQ,YAAuB,IAApBM,EAAmB,EAAnBA,KAAmB,EAAbgC,OACjCL,EAAUM,SAASjC,IAAUwB,EAAKU,IAAIlC,IAC1C2B,EAAUlC,KAAKO,SAKlB0B,EAAK,UAAOC,IAjBW,IAAjBD,EAAMS,QAAe,IAmB5B,OAAO3B,GCCR,SAAS4B,EAASd,EAAGe,EAAMC,EAAGC,EAASC,EAAYC,EAAKb,EAAQc,GAC/DL,IACAE,EAAQV,IAAIS,GACZE,EAAWF,GAAKD,EAChBI,EAAIH,GAAKD,EAGSf,EAAEQ,QAAQC,IAAIO,GACtB5C,SAAQ,YAA0B,IAAjBiD,EAAgB,EAAtB3C,KAAsB,EAAbgC,OACxBO,EAAQL,IAAIS,GAQNA,IAAMf,EAAOU,KACvBG,EAAIH,GAAKM,KAAKC,IAAIJ,EAAIH,GAAIE,EAAWG,MARrCf,EAAOe,GAAKL,EACZF,EAASd,EAAGe,EAAMM,EAAGJ,EAASC,EAAYC,EAAKb,EAAQc,GACvDD,EAAIH,GAAKM,KAAKC,IAAIJ,EAAIH,GAAIG,EAAIE,IAE1BF,EAAIE,GAAKH,EAAWF,IACvBI,EAAQb,IAAI,CAAEf,MAAOwB,EAAGvB,MAAO4B,QAQpBD,MAhDC,SAACpB,GAChB,IAGIoB,EAAU,IAAIjB,IAEdc,EAAU,IAAId,IAEdG,EAAS,GAETY,EAAa,GAGbC,EAAM,GAQV,OANAnB,EAAEQ,QAAQpC,SAAQ,SAACoD,EAAQ9C,GACrBuC,EAAQL,IAAIlC,IAChBoC,EAASd,EAhBA,EAgBStB,EAAMuC,EAASC,EAAYC,EAAKb,EAAQc,MAIrDA,GCdFK,EAAuB,SAACzB,EAAGtB,GAC/B,IAAMgD,EAAY1B,EAAEQ,QAAQC,IAAI/B,GAE1BiD,EAAeD,EAAUb,OAEzBe,EAAWC,EAAUF,IAA+C,EAA9BE,EAAUF,EAAe,IAGjEG,EAAQ,EACZJ,EAAUtD,SAAQ,YAAmC,IAA1B2D,EAAyB,EAA/BrD,KAA+B,EAAbgC,OACrCgB,EAAUtD,SAAQ,YAAqC,IAA5B4D,EAA2B,EAAjCtD,KAAiC,EAAduD,QAClCF,IAAeC,GACHhC,EAAEQ,QAAQC,IAAIsB,GACtB3D,SAAQ,YAAqC,IAA5B8D,EAA2B,EAAjCxD,KAAiC,EAAdyD,QAClCL,GAASI,IAAgBF,EAAc,EAAI,WAOnD,IAAMI,EAAWN,GAAS9B,EAAEqC,MAAMC,WAAa,EAAM,GAC/CC,EAAQvC,EAAEqC,MAAMC,WAClBV,EACAD,GAAgBA,EAAe,GACnC,OAAiB,IAAVY,EAAcH,EAAWG,EAAQ,GAI1C,SAASV,EAAUW,GACjB,GAAY,IAARA,GAAqB,IAARA,EACf,OAAO,EAET,IAAK,IAAIC,EAAID,EAAM,EAAGC,EAAI,EAAGA,IAC3BD,GAAOC,EAET,OAAOD,EAGME,MAhDe,SAAC1C,GAC7B,IAAMd,EAAM,GAKZ,OAHAc,EAAEQ,QAAQpC,SAAQ,SAACsD,EAAWhD,GAC5BQ,EAAIf,KAAK,CAAEO,KAAMA,EAAMU,GAAIqC,EAAqBzB,EAAGtB,QAE9CQ,GC2BMyD,EAhCH,SAAC3C,EAAGC,GAEf,IAAM2C,EAAQ,GAER9E,EAAS,GAEToD,EAAa,IAAIf,IAIvB,IAFAyC,EAAMzE,KAAK8B,GAEa,IAAjB2C,EAAM/B,QAAc,CAE1B,IAAMgC,EAAOD,EAAME,MACbC,EAAe/C,EAAEQ,QAAQC,IAAIoC,GAG9B3B,EAAWN,IAAIiC,KACnB/E,EAAOK,KAAK0E,GACZ3B,EAAWX,IAAIsC,IAIhBE,EAAa3E,SAAQ,YAAuB,IAApBM,EAAmB,EAAnBA,KAAmB,EAAbgC,OACxBQ,EAAWN,IAAIlC,IACnBkE,EAAMzE,KAAKO,MAKd,OAAOZ,GCIOkF,EAlCE,SAAChD,EAAGC,GAEpB,IAAMgD,EAAY,IAAIC,IAEhBhE,EAAM,GAEZc,EAAEQ,QAAQpC,SAAQ,SAAC+E,EAAOzE,GAAR,OAAiBuE,EAAUG,IAAI1E,EAAM2E,OAAOC,cAC9DL,EAAUG,IAAInD,EAAO,GAKrB,IAFA,IAAIsD,EAAgB,EACdC,EAAUxD,EAAEQ,QAAQjB,KAXI,aAa7B,IAAIkE,EAAUJ,OAAOC,UACjBI,GAAW,EACfT,EAAU7E,SAAQ,SAACuF,EAAKC,GAEnBD,EAAMF,IACTC,EAAUE,EACVH,EAAUE,MAGRD,GAAW,IACdxE,EAAIf,KAAK,CAAEO,KAAMgF,EAAS3E,SAAU0E,IACpCR,EAAUY,OAAOH,GAEjB1D,EAAEQ,QAAQC,IAAIiD,GAAStF,SAAQ,YAAuB,IAApBM,EAAmB,EAAnBA,KAAMgC,EAAa,EAAbA,OACvCuC,EAAUG,IAAI1E,EAAM4C,KAAKC,IAAI0B,EAAUxC,IAAI/B,GAAO+E,EAAU/C,SAfxD6C,IAAkBC,GAAU,IAmBnC,OAAOtE,GCNR,SAAS4B,EAASd,EAAGtB,EAAMoF,EAAOC,GACjCD,EAAMV,IAAI1E,EAAM,GAEhB,IAAMgD,EAAY1B,EAAEQ,QAAQC,IAAI/B,GAC5BO,GAAQ,EAmBZ,OAlBAyC,EAAUtD,SAAQ,YAA0B,IAAjBiD,EAAgB,EAAtB3C,KAAsB,EAAbgC,OAER,IAAjBoD,EAAMrD,IAAIY,KACbpC,GAAQ,GAIY,IAAjB6E,EAAMrD,IAAIY,KACRP,EAASd,EAAGqB,EAAGyC,EAAOC,KAC1B9E,GAAQ,OAMX6E,EAAMV,IAAI1E,EAAM,GAEhBqF,EAAS5F,KAAKO,GACPO,EAGO+E,MAnDE,SAAChE,GAEjB,IAAM+D,EAAW,GAEXD,EAAQ,IAAIZ,IACdjE,GAAQ,EAgBZ,OAbAe,EAAEQ,QAAQpC,SAAQ,SAACoD,EAAQ9C,GAC1BoF,EAAMV,IAAI1E,EAAM,MAGjBsB,EAAEQ,QAAQpC,SAAQ,SAACoD,EAAQ9C,GAEF,IAApBoF,EAAMrD,IAAI/B,KACRoC,EAASd,EAAGtB,EAAMoF,EAAOC,KAC7B9E,GAAQ,OAKJ,CAAEA,MAAOA,EAAOC,IAAK6E,EAASE,YCQhCC,EAAe,SAACC,EAAYC,GAChC,IAAIC,GAAW,EAMf,OALAF,EAAW/F,SAAQ,YAA8B,IAArBkG,EAAoB,EAA1B5F,KAA0B,EAAbgC,OAC7B4D,IAAUF,IACZC,GAAW,MAGRA,GAIHE,EAAgB,SAACJ,EAAYK,GACjC,IAAIC,GAAS,EAMb,OALAN,EAAW/F,SAAQ,SAACsG,GACdF,EAAWG,MAAK,SAACC,GAAD,OAAeF,EAAUhG,OAASkG,EAAUlG,UAC9D+F,GAAS,MAGNA,GAGMI,EAhDQ,SAAC7E,GACtB,IAAMd,EAAM,IAAIiB,IAsBhB,OAdAH,EAAEQ,QAAQpC,SAAQ,SAAC+F,EAAYG,GAC7BtE,EAAEQ,QAAQpC,SAAQ,SAACoG,EAAYJ,GAE3BE,IAAUF,GACVG,EAAcJ,EAAYK,KACzBN,EACCC,EACAC,IAGFlF,EAAIqB,IAAI,CAAEZ,MAAO2E,EAAO1E,MAAOwE,UAI9BlF,GCZH4F,EAAM,KAGNC,EAAc,SAACC,EAAUC,EAAGC,GAChC,MAAO,CACLC,QAAS,EACTC,OAAQ,GACRC,SAAU,WACVC,gBAAiBN,EAAW,UAAY,UACxCO,aAAc,MACdC,OAAQ,kBACRC,MAAOX,EACPY,OAAQZ,EACRa,WAAW,GAAD,OAAKb,EAAL,MACVc,KAAK,GAAD,OAAKX,EAAIH,MAAT,MACJe,IAAI,GAAD,OAAKX,EAAIJ,MAAT,MACHgB,aAAc,IAUZC,EAAe,SAACC,GACpB,MAAO,CACLC,OAAQ,EACRC,YAAa,EACbC,aAAc,CAAE5H,GAAI,EAAGC,GAAI,GAC3B8D,WAAmC,eAAvB0D,EAAMI,aAClBC,WAAqC,eAAzBL,EAAMM,eAClBvI,UAAWiI,EAAMjI,UACjBwI,QAASP,EAAMO,QACfC,QAASR,EAAMlI,OAASkI,EAAMlI,OAAS,GACvC2I,MAAM,IAqZKC,E,kDAhZb,WAAYV,GAAQ,IAAD,8BACjB,cAAMA,IAwGRW,eAAiB,SAACC,GAEhB,IACIC,EADID,EAAME,OACFC,wBAGZ,MAAO,CAFCH,EAAMI,QAAUH,EAAIjB,KACpBgB,EAAMK,QAAUJ,EAAIhB,MA9GX,EAoHnBqB,QAAU,SAACC,EAAGC,GACZ,IAAK,EAAK5G,QAAQI,IAAIwG,GAAK,CACzB,EAAK5G,QAAQ4C,IAAIgE,EAAI,IADI,MAGV,EAAKT,eAAeQ,GAHV,mBAGlBlC,EAHkB,KAGfC,EAHe,KAIzB,EAAKmC,cAAcjE,IAAIgE,GAAI,kBACzB,cAAC,IAAD,CACEE,OAAO,SAEPC,OAAQ,SAACJ,EAAGK,GACV,EAAKC,SAAS,CAAEC,SAAS,IACzB,EAAKC,eALT,SAQE,qBACEC,SAAS,IACTC,UAAW,SAACV,GACI,cAAVA,EAAEvD,KAAiC,WAAVuD,EAAEvD,KAC7B,EAAKkE,WAAWV,IAGpBW,MAAOhD,EAAY,EAAK1C,MAAM6D,aAAekB,EAAInC,EAAGC,GACpD8C,QAAS,SAACb,GACJA,EAAEc,SACJ,EAAKC,QAAQ,EAAK7F,MAAM6D,WAAYkB,EAAI,GAExC,EAAKe,WAAWhB,EAAGC,GAErB,EAAKO,eAEP/J,UAAS,cAASwJ,GAClBA,GAAE,cAASA,GAjBb,SAmBGA,KAzBEA,MA8BT,EAAKK,SAAS,CAAEvB,WAAYkB,IAAM,WAChC,EAAKO,iBAGT,OAAO,gBA9JU,EAmKnBG,WAAa,SAACV,GAaZ,OAXA,EAAK5G,QAAQpC,SAAQ,SAACsD,EAAWhD,GAC/B,EAAK8B,QAAQ4C,IACX1E,EACAgD,EAAU0G,QAAO,SAACzE,GAAD,OAASA,IAAQyD,MAIpC,EAAK5G,QAAQqD,OAAOuD,GACpB,EAAKC,cAAcxD,OAAOuD,MAE5B,EAAKO,cACE,gBAhLU,EAoLnBO,QAAU,SAACG,EAASC,EAAQ5H,GA4B1B,OA3BI,EAAKF,QAAQI,IAAIyH,IAAY,EAAK7H,QAAQI,IAAI0H,KAChD,EAAK9H,QAAQ4C,IAAIiF,EAAjB,sBACK,EAAK7H,QAAQC,IAAI4H,GAASD,QAAO,SAACG,GAAD,OAASA,EAAI7J,OAAS4J,MAD5D,CAEE,CAAE5J,KAAM4J,EAAQ5H,OAAQA,MAEtB,EAAK2B,MAAMC,YACb,EAAK9B,QAAQ4C,IAAIkF,EAAjB,sBACK,EAAK9H,QAAQC,IAAI6H,GAAQF,QAAO,SAACG,GAAD,OAASA,EAAI7J,OAAS2J,MAD3D,CAEE,CAAE3J,KAAM2J,EAAS3H,OAAQA,MAG7B,EAAK+G,SACH,CACEC,SAAS,EACTxB,WAAYoC,IAEd,WACE,EAAKE,sBAAsB,CACzBjC,QAAS,EAAKlE,MAAMkE,QACpBH,aAAc,EAAK/D,MAAMC,WAAa,aAAe,WACrDgE,eAAgB,EAAKjE,MAAMgE,WAAa,aAAe,WACvDoC,kBAAmB,EAAKpG,MAAMtE,gBAKtC,EAAK4J,cACE,gBAhNU,EAoNnBe,WAAa,SAACL,EAASC,GAcrB,OAbI,EAAK9H,QAAQI,IAAIyH,KACnB,EAAK7H,QAAQ4C,IACXiF,EACA,EAAK7H,QAAQC,IAAI4H,GAASD,QAAO,SAACG,GAAD,OAASA,EAAI7J,OAAS4J,MAErD,EAAKjG,MAAMC,YACb,EAAK9B,QAAQ4C,IACXkF,EACA,EAAK9H,QAAQC,IAAI6H,GAAQF,QAAO,SAACG,GAAD,OAASA,EAAI7J,OAAS2J,OAI5D,EAAKV,cACE,gBAlOU,EAqOnBQ,WAAa,SAAChB,EAAGC,GACf,EAAKK,SACH,CACEvB,WAAYkB,EACZjB,aAAc,CAAE5H,GAAI,EAAGC,GAAI,GAC3BkJ,SAAS,IAEX,WACE,EAAKc,sBAAsB,CACzBjC,QAAS,EAAKlE,MAAMkE,QACpBH,aAAc,EAAK/D,MAAMC,WAAa,aAAe,WACrDgE,eAAgB,EAAKjE,MAAMgE,WAAa,aAAe,WACvDoC,kBAAmB,EAAKpG,MAAMtE,eAKpC,EAAK4J,cACLR,EAAEwB,mBApPF,EAAKnI,QAAU,IAAI0C,IACnB,EAAKmE,cAAgB,IAAInE,IAEzB,EAAKb,MAAQ0D,EAAaC,GAE1B,EAAKW,eAAiB,EAAKA,eAAeiC,KAApB,gBACtB,EAAK1B,QAAU,EAAKA,QAAQ0B,KAAb,gBACf,EAAKT,WAAa,EAAKA,WAAWS,KAAhB,gBAClB,EAAKV,QAAU,EAAKA,QAAQU,KAAb,gBAXE,E,yDAcnB,SAAsBC,GAAY,IAAD,OAE3BC,GAAU,EA+Bd,GA7B8B,eAA3BD,EAAUzC,eAAmC2C,KAAK1G,MAAMC,YAC3B,eAA7BuG,EAAUvC,iBAAqCyC,KAAK1G,MAAMgE,aAG7B,eAA3BwC,EAAUzC,eAAmC2C,KAAK1G,MAAMC,YACxDyG,KAAK1G,MAAMC,YAEZyG,KAAKvI,QAAQpC,SAAQ,SAACsD,EAAW0F,GAC/B1F,EAAUtD,SAAQ,YAAuB,IAApBM,EAAmB,EAAnBA,KAAMgC,EAAa,EAAbA,OACzB,EAAKwH,QAAQxJ,EAAM0I,EAAI1G,SAI7BqI,KAAKtB,SAAS,CACZnF,WAAuC,eAA3BuG,EAAUzC,aACtBC,WAAyC,eAA7BwC,EAAUvC,iBAExBwC,GAAU,GAIRC,KAAK1G,MAAMkE,UAAYsC,EAAUtC,UACnCwC,KAAKvI,QAAU,IAAI0C,IACnB6F,KAAK1B,cAAgB,IAAInE,IACzB6F,KAAKtB,SAAS1B,EAAa8C,IAC3BC,GAAU,GAKVC,KAAK1G,MAAMtE,YAAc8K,EAAUJ,mBACnCM,KAAK1G,MAAMqF,QACX,CACA,IAAI5J,EACJ,OAAQ+K,EAAUJ,mBAChB,IAAK,MAECM,KAAK1G,MAAM6D,YAAc,IAC3BpI,EAASiC,EAAIgJ,KAAMA,KAAK1G,MAAM6D,aAEhC,MACF,IAAK,MAEC6C,KAAK1G,MAAM6D,YAAc,IAC3BpI,EAAS6E,EAAIoG,KAAMA,KAAK1G,MAAM6D,aAEhC,MACF,IAAK,WAEC6C,KAAK1G,MAAM6D,YAAc,IAC3BpI,EAASkF,EAAS+F,KAAMA,KAAK1G,MAAM6D,aAErC,MACF,IAAK,YAEHpI,EAASkG,EAAS+E,MAClB,MACF,IAAK,aAECA,KAAK1G,MAAM6D,YAAc,IAC3BpI,EAAS4E,EAAsBqG,KAAMA,KAAK1G,MAAM6D,aAElD,MACF,IAAK,UAEHpI,EAASsD,EAAQ2H,MACjB,MACF,IAAK,UAEHjL,EAAS+G,EAAekE,MAM5BA,KAAKtB,SAAS,CACZjB,QAAS1I,EACTC,UAAW8K,EAAUJ,kBACrBf,SAAS,IAEXqB,KAAKpB,cACLmB,GAAU,EAEZ,OAAOA,I,oBAqJT,WAIE,IAJQ,IAAD,OACDE,EAAQ,GACRC,EAAKF,KAAK1B,cAAc7F,SAC1BtC,EAAM+J,EAAGC,QACLhK,EAAIiK,MACVH,EAAM7K,KAAKe,EAAIiE,SACfjE,EAAM+J,EAAGC,OAEX,IAAME,EAAQ,GACRC,EAAa,GACnBN,KAAKvI,QAAQpC,SAAQ,SAACsD,EAAW0F,GAC/B1F,EAAUtD,SAAQ,SAACkL,GAzRP,IAACtE,EA2RR,EAAK3C,MAAMC,YACX+G,EAAW1E,MACV,gBAAG2D,EAAH,EAAGA,OAAQD,EAAX,EAAWA,QAAX,OAAyBC,IAAWgB,EAAS5K,MAAQ2J,IAAYjB,OAGnEiC,EAAWlL,KAAK,CAAEmK,OAAQlB,EAAIiB,QAASiB,EAAS5K,OAChD0K,EAAMjL,KACJ,cAAC,IAAD,CAEE8B,MAAK,cAASmH,GACdmC,IAAG,cAASD,EAAS5K,MACrB8K,MAAQ,EAAKnH,MAAMgE,WAAoC,GAAhD,UAA4BiD,EAAS5I,QAC5C+I,UAAW,EAAKpH,MAAMC,WACtBwB,OAxSKkB,EAySH,EAAK3C,MAAM8D,aAAa5H,IAAM6I,GAC5B,EAAK/E,MAAM8D,aAAa3H,IAAM8K,EAAS5K,KAzShDsG,EAAW,UAAY,WA2SlB0E,YAAa,EACb1B,QAAS,SAACb,GACR,EAAKM,SAAS,CACZvB,YAAa,EACbC,aAAc,CAAE5H,EAAG6I,EAAI5I,EAAG8K,EAAS5K,QAErCyI,EAAEwB,kBACF,EAAKhB,eAEPC,SAAS,IACTC,UAAW,SAACV,GACV,GAAc,cAAVA,EAAEvD,KAAiC,WAAVuD,EAAEvD,IAC7B,EAAK8E,WAAWtB,EAAIkC,EAAS5K,MAC7B,EAAK+I,SAAS,CACZtB,aAAc,CAAE5H,GAAI,EAAGC,GAAI,UAExB,GAAc,UAAV2I,EAAEvD,IACX,EAAK8E,WAAWtB,EAAIkC,EAAS5K,MAC7B,EAAKwJ,QAAQd,EAAIkC,EAAS5K,KAAM,QAC3B,GACK,MAAVyI,EAAEvD,KACQ,MAAVuD,EAAEvD,KACQ,MAAVuD,EAAEvD,KACQ,MAAVuD,EAAEvD,KACQ,MAAVuD,EAAEvD,KACQ,MAAVuD,EAAEvD,KACQ,MAAVuD,EAAEvD,KACQ,MAAVuD,EAAEvD,KACQ,MAAVuD,EAAEvD,KACQ,MAAVuD,EAAEvD,IACF,CACA,IAAI+F,EAAa,EACjB,EAAKnJ,QACFC,IAAI2G,GACJhJ,SACC,gBAAGM,EAAH,EAAGA,KAAMgC,EAAT,EAASA,OAAT,OACGiJ,EACCjL,IAAS4K,EAAS5K,KAAOgC,EAASiJ,KAE1C,EAAKjB,WAAWtB,EAAIkC,EAAS5K,MAC7B,EAAKwJ,QACHd,EACAkC,EAAS5K,KACI,GAAbiL,EAAkBC,SAASzC,EAAEvD,MAG/B,EAAK+D,cAEP,EAAKF,SAAS,CAAEC,SAAS,MA1D7B,cACcN,EADd,gBACwBkC,EAAS5K,eAiEzC,IAAMmL,EAAc,GACdC,EAAmB,GA0BzB,MAzB6B,YAAzBf,KAAK1G,MAAMtE,WACbgL,KAAK1G,MAAMmE,QAAQpI,SAAQ,YAAuB,IAApBuB,EAAmB,EAAnBA,MAAOC,EAAY,EAAZA,MAEhC,EAAKyC,MAAMC,YACXwH,EAAiBnF,MAChB,gBAAG2D,EAAH,EAAGA,OAAQD,EAAX,EAAWA,QAAX,OAAyBC,IAAW1I,GAASyI,IAAY1I,OAG3DmK,EAAiB3L,KAAK,CAAEmK,OAAQ3I,EAAO0I,QAASzI,IAChDiK,EAAY1L,KACV,cAAC,IAAD,CAEE8B,MAAK,cAASN,GACd4J,IAAG,cAAS3J,GACZ4J,MAAO,GACPC,UAAW,EAAKpH,MAAMC,WACtBwB,MAAO,UACP4F,YAAa,EACbK,SAAU,CAAEC,UAAW,GAAIC,aAAc,KAR3C,cACctK,EADd,gBAC2BC,SAejC,sBACEoI,QAAS,WACP,EAAKP,SAAS,CACZvB,YAAa,EACbC,aAAc,CAAE5H,GAAI,EAAGC,GAAI,KAG7B,EAAKmJ,eAEPuC,cAAe,SAAC/C,GAEZ,EAAK9E,MAAM6D,WAAa,IACO,IAA/B,EAAK7D,MAAM8D,aAAa5H,IACO,IAA/B,EAAK8D,MAAM8D,aAAa3H,IAExB,EAAK0I,QAAQC,EAAG,EAAK9E,MAAM4D,QAC3B,EAAKwB,SAAS,CACZxB,OAAQ,EAAK5D,MAAM4D,OAAS,EAC5BE,aAAc,CAAE5H,GAAI,EAAGC,GAAI,KAE7B,EAAKmJ,gBAGT/J,UAAU,SAvBZ,UAyBE,sBAAKA,UAAU,QAAf,UACGiM,EACAT,EACAJ,KAEH,cAAC,EAAD,CAASlL,OAAQiL,KAAK1G,MAAMmE,QAASzI,UAAWgL,KAAK1G,MAAMtE,mB,GA3Y/CoM,a,0FCsLLC,EA/NC,SAAC,GAQV,IAPLhE,EAOI,EAPJA,aACAiE,EAMI,EANJA,gBACA/D,EAKI,EALJA,eACAgE,EAII,EAJJA,kBACAC,EAGI,EAHJA,qBACAC,EAEI,EAFJA,WACAjE,EACI,EADJA,QAEMkE,EACJ,0GAEE,uBAFF,sEAIE,uBAJF,kEAKkE,IAChE,6CANF,OAM4B,0CAN5B,yBAOE,uBACA,uBARF,sEASsE,IACpE,yCAVF,kGAYE,uBACA,uBAbF,mOAFE,EAwBoBC,oBAAS,GAxB7B,mBAwBGjE,EAxBH,KAwBSkE,EAxBT,KAgCEC,EAAc,WAClBD,GAAQ,IAIJE,EAAa,SAACC,GAClB,MACU,QAARA,GACQ,QAARA,GACQ,aAARA,GACQ,eAARA,IAGiB,YAARA,EACe,eAAjB1E,EACU,cAAR0E,GACe,aAAjB1E,IAOL2E,EAAe,SAAC5D,EAAG6D,GACvB,OAAQA,GACN,IAAK,YACHX,EAAgBlD,EAAEL,OAAO3D,OACzB,MACF,IAAK,SACHmH,EAAkBnD,EAAEL,OAAO3D,OAC3B,MACF,QACE8H,QAAQC,IAAI,kBAMlB,OACE,sBAAKtN,UAAU,UAAf,UACE,sBAAKA,UAAU,eAAf,UACE,sBAAKA,UAAU,MAAf,UACE,cAACuN,EAAA,EAAD,CAAQC,QAAQ,YAAYpD,QA/CZ,WACtB2C,GAAQ,IA8CF,0BAGA,eAACU,EAAA,EAAD,CACE5E,KAAMA,EACN6E,QAASV,EACTW,kBAAgB,qBAChBC,mBAAiB,2BAJnB,UAME,cAACC,EAAA,EAAD,CAAarE,GAAG,qBAAhB,SAAsC,iBACtC,cAACsE,EAAA,EAAD,UACE,cAACC,EAAA,EAAD,CAAmBvE,GAAG,2BAAtB,SACGqD,MAGL,cAACmB,EAAA,EAAD,UACE,cAACT,EAAA,EAAD,CAAQnD,QAAS4C,EAAa9G,MAAM,UAAU+H,WAAS,EAAvD,4BAMN,qBAAKjO,UAAU,MAAf,SACE,cAACuN,EAAA,EAAD,CACEC,QAAQ,WACRpD,QAAS,kBAAMuC,EAAqB,QACpCuB,SAAUjB,EAAW,OAHvB,mBAQF,qBAAKjN,UAAU,MAAf,SACE,cAACuN,EAAA,EAAD,CACEC,QAAQ,WACRpD,QAAS,SAACb,GAAD,OAAOoD,EAAqB,QACrCuB,SAAUjB,EAAW,OAHvB,mBAQF,qBAAKjN,UAAU,MAAf,SACE,cAACuN,EAAA,EAAD,CACEC,QAAQ,WACRpD,QAAS,SAACb,GAAD,OAAOoD,EAAqB,aACrCuB,SAAUjB,EAAW,YAHvB,wBAQF,qBAAKjN,UAAU,MAAf,SACE,cAACuN,EAAA,EAAD,CACEC,QAAQ,WACRpD,QAAS,SAACb,GAAD,OAAOoD,EAAqB,cACrCuB,SAAUjB,EAAW,aAHvB,yBAQF,qBAAKjN,UAAU,MAAf,SACE,cAACuN,EAAA,EAAD,CACEC,QAAQ,WACRpD,QAAS,SAACb,GAAD,OAAOoD,EAAqB,eACrCuB,SAAUjB,EAAW,cAHvB,sCAQF,qBAAKjN,UAAU,MAAf,SACE,cAACuN,EAAA,EAAD,CACEC,QAAQ,WACRpD,QAAS,SAACb,GAAD,OAAOoD,EAAqB,YACrCuB,SAAUjB,EAAW,WAHvB,uBAQF,qBAAKjN,UAAU,MAAf,SACE,cAACuN,EAAA,EAAD,CACEC,QAAQ,WACRpD,QAAS,SAACb,GAAD,OAAOoD,EAAqB,YACrCuB,SAAUjB,EAAW,WAHvB,+BAQF,qBAAKjN,UAAU,MAAf,SACE,cAACuN,EAAA,EAAD,CACEC,QAAQ,YACRtH,MAAM,YACNkE,QAAS,WACPwC,GAAYjE,GACZgE,EAAqB,KALzB,wBAYJ,cAACwB,EAAA,EAAD,CAAaC,UAAU,WAAvB,SACE,eAACC,EAAA,EAAD,CACEC,aAAW,aACXC,KAAK,iCACLhJ,MAAOiD,EACPgG,SAAU,SAACjF,GAAD,OAAO4D,EAAa5D,EAAG,cAJnC,UAME,cAACkF,EAAA,EAAD,CACElJ,MAAM,aACNmJ,QAAS,cAACC,EAAA,EAAD,CAAOzI,MAAM,YACtB0F,MAAM,eAER,cAAC6C,EAAA,EAAD,CACElJ,MAAM,WACNmJ,QAAS,cAACC,EAAA,EAAD,CAAOzI,MAAM,YACtB0F,MAAM,kBAKZ,cAACuC,EAAA,EAAD,CAAaC,UAAU,WAAvB,SACE,eAACC,EAAA,EAAD,CACEC,aAAW,YACXC,KAAK,iCACLhJ,MAAOmD,EACP8F,SAAU,SAACjF,GAAD,OAAO4D,EAAa5D,EAAG,WAJnC,UAME,cAACkF,EAAA,EAAD,CACElJ,MAAM,aACNmJ,QAAS,cAACC,EAAA,EAAD,CAAOzI,MAAM,YACtB0F,MAAM,eAER,cAAC6C,EAAA,EAAD,CACElJ,MAAM,WACNmJ,QAAS,cAACC,EAAA,EAAD,CAAOzI,MAAM,YACtB0F,MAAM,sBChMHgD,MA/Bf,WAAe,MAE0B9B,mBAAS,cAFnC,mBAEPtE,EAFO,KAEOiE,EAFP,OAI8BK,mBAAS,cAJvC,mBAIPpE,EAJO,KAISgE,EAJT,OAMoCI,mBAAS,IAN7C,mBAMPjC,EANO,KAMY8B,EANZ,OAQgBG,oBAAS,GARzB,mBAQPnE,EARO,KAQEiE,EARF,KAUd,OACC,sBAAK5M,UAAU,MAAf,UACC,cAAC,EAAD,CACCwI,aAAcA,EACdE,eAAgBA,EAChBmC,kBAAmBA,EACnBlC,QAASA,IAEV,cAAC,EAAD,CACCH,aAAcA,EACdiE,gBAAiBA,EACjB/D,eAAgBA,EAChBgE,kBAAmBA,EACnBC,qBAAsBA,EACtBhE,QAASA,EACTiE,WAAYA,QCzBhBiC,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,U","file":"static/js/main.f0bb6863.chunk.js","sourcesContent":["import React from \"react\";\n\nconst emptyResults = (\n  <div className=\"results\">\n    <h2 className=\"results-heading\">Results</h2>\n    <div className=\"output-window\">Click on an algorithm to get started!</div>\n  </div>\n);\n\nconst resultsToText = (result, algorithm) => {\n  const separator = \"----------\";\n  switch (algorithm) {\n    case \"bfs\":\n      let bfsString = [];\n      var frontierCount = 0;\n      bfsString.push(`Source Node: Node${result[0][0]}`);\n      result.forEach((frontier) => {\n        frontier = frontier.sort(function (a, b) {\n          return a - b;\n        });\n        let currString = `Frontier ${frontierCount++}: `;\n        frontier.forEach((node) => (currString += `Node${node}, `));\n        currString = currString.slice(0, currString.lastIndexOf(\",\")); // slice off last \", \"\n        bfsString.push(\n          <div key={frontierCount}>\n            - {currString}\n            <br />\n          </div>\n        );\n      });\n      return (\n        <>\n          BFS\n          <br />\n          {separator}\n          <br />\n          {bfsString}\n        </>\n      );\n    case \"dfs\":\n      let dfsString = [];\n      result.forEach((node) =>\n        dfsString.push(\n          <div key={node}>\n            - Node{node}\n            <br />\n          </div>\n        )\n      );\n      return (\n        <>\n          DFS\n          <br />\n          {separator}\n          <br />\n          Order of Nodes Visited:\n          <br />\n          {dfsString}\n        </>\n      );\n    case \"dijkstra\":\n      let dijkstraString = [];\n      result.forEach(({ node, distance }) => {\n        dijkstraString.push(\n          <div key={`Node${node}: ${distance} units`}>\n            - Node{node}: {distance} units\n            <br />\n          </div>\n        );\n      });\n      return (\n        <>\n          Dijkstra\n          <br />\n          {separator}\n          <br />\n          Shortest distances from Node{result[0].node}:\n          <br />\n          {dijkstraString}\n        </>\n      );\n    case \"topo sort\":\n      let topoString = [];\n      if (!result.valid) {\n        topoString.push(\"No valid topo sort, graph cannot have cycle.\");\n      } else {\n        topoString.push(\n          <>\n            One potential ordering:\n            <br />\n          </>\n        );\n        result.res.forEach((node) => {\n          topoString.push(\n            <div key={node}>\n              - Node{node}\n              <br />\n            </div>\n          );\n        });\n      }\n      return (\n        <>\n          Topological Sort\n          <br />\n          {separator}\n          <br />\n          {topoString}\n        </>\n      );\n    case \"clustering\":\n      let clusteringString = [];\n      result.forEach(({ node, cc }) => {\n        clusteringString.push(\n          <div key={node}>\n            - Node{node}: {cc.toFixed(2)}\n            <br />\n          </div>\n        );\n      });\n      return (\n        <>\n          Clustering Coefficient\n          <br />\n          {separator}\n          <br />\n          {clusteringString}\n        </>\n      );\n    case \"bridges\":\n      let bridgesString = [];\n      if (result.size === 0) {\n        bridgesString.push(\"No global bridges found.\");\n      } else {\n        bridgesString.push(\n          <div>\n            Global Bridges:\n            <br />\n          </div>\n        );\n        result.forEach(({ node1, node2 }) => {\n          bridgesString.push(\n            <div key={`Node${node1} -> Node${node2}`}>\n              - Node{node1} {\"<->\"} Node{node2}\n              <br />\n            </div>\n          );\n        });\n      }\n      return (\n        <>\n          Global Bridges\n          <br />\n          {separator}\n          <br />\n          {bridgesString}\n        </>\n      );\n    case \"triadic\":\n      let triadicString = [];\n      if (result.size === 0) {\n        triadicString.push(\n          <div>\n            No new edges would be formed due to Triadic Closure.\n            <br />\n          </div>\n        );\n      } else {\n        triadicString.push(\n          <div>\n            New Edges Formed due to Triadic Closure:\n            <br />\n          </div>\n        );\n        result.forEach(({ NodeA, NodeB }) => {\n          triadicString.push(\n            <div key={`Node${NodeA} -> Node${NodeB}`}>\n              - Node{NodeA} {\"->\"} Node{NodeB}\n              <br />\n            </div>\n          );\n        });\n      }\n      return (\n        <>\n          Triadic Closure\n          <br />\n          {separator}\n          <br />\n          {triadicString}\n        </>\n      );\n    default:\n      return \"\";\n  }\n};\n\nconst Results = ({ result, algorithm }) => {\n  const emptyCondition =\n    result === undefined || algorithm === undefined || algorithm === \"\";\n  return emptyCondition ? (\n    emptyResults\n  ) : (\n    <div className=\"results\">\n      <h2 className=\"results-heading\">Results</h2>\n      <div className=\"output-window\">{resultsToText(result, algorithm)}</div>\n    </div>\n  );\n};\n\nexport default Results;\n","// performs full BFS traversal from given start node\nconst bfs = (g, start) => {\n\tconst seen = new Set();\n\t// queue for BFS\n\tlet queue = [start];\n\t// list of lists to store each layer/frontier of BFS traversal\n\tlet res = [];\n\t// while queue is not empty, proceed\n\twhile (queue.length !== 0) {\n\t\t// add current layer/frontier\n\t\tres.push([...queue]);\n\t\tlet tempQueue = [];\n\t\t// mark all parents as seen / discovered\n\t\tqueue.forEach((parent) => {\n\t\t\tseen.add(parent);\n\t\t});\n\t\t// add next layer/frontier of nodes to queue if we haven't seen it already\n\t\tqueue.forEach((parent) => {\n\t\t\tg.adjList.get(parent).forEach(({ node, weight }) => {\n\t\t\t\tif (!tempQueue.includes(node) && !seen.has(node)) {\n\t\t\t\t\ttempQueue.push(node);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\t// update queue\n\t\tqueue = [...tempQueue];\n\t}\n\treturn res;\n};\n\nexport default bfs;\n","/* Algorithm using modified DFS traversal to find all edges\nthat disconnect an UNDIRECTED graph (i.e. global bridges) */\n// Reference: https://www.geeksforgeeks.org/bridge-in-a-graph/\nconst bridges = (g) => {\n\tlet time = 0;\n\n\t// store edges that are bridges\n\tlet bridges = new Set();\n\t// stores which nodes have been visited in DFS\n\tlet visited = new Set();\n\t// maps nodes to parent nodes in DFS tree\n\tlet parent = {};\n\t// map nodes to discovery time\n\tlet discovered = {};\n\t// map indicating whether some node discovered earlier\n\t// can be visited by subtree rooted at that node\n\tlet low = {};\n\n\tg.adjList.forEach((values, node) => {\n\t\tif (!visited.has(node)) {\n\t\t\tdfsVisit(g, time, node, visited, discovered, low, parent, bridges);\n\t\t}\n\t});\n\n\treturn bridges;\n};\n\n// DFS helper method\nfunction dfsVisit(g, time, u, visited, discovered, low, parent, bridges) {\n\ttime++;\n\tvisited.add(u);\n\tdiscovered[u] = time;\n\tlow[u] = time;\n\n\t// iterate through neighbors\n\tconst neighbors = g.adjList.get(u);\n\tneighbors.forEach(({ node: v, weight }) => {\n\t\tif (!visited.has(v)) {\n\t\t\tparent[v] = u;\n\t\t\tdfsVisit(g, time, v, visited, discovered, low, parent, bridges);\n\t\t\tlow[u] = Math.min(low[u], low[v]);\n\n\t\t\tif (low[v] > discovered[u]) {\n\t\t\t\tbridges.add({ node1: u, node2: v });\n\t\t\t}\n\t\t} else if (v !== parent[u]) {\n\t\t\tlow[u] = Math.min(low[u], discovered[v]);\n\t\t}\n\t});\n}\n\nexport default bridges;\n","// calculates clustering coefficient for given node\nconst clusteringCoefficient = (g) => {\n  const res = [];\n\n  g.adjList.forEach((neighbors, node) => {\n    res.push({ node: node, cc: clusteringIndividual(g, node) });\n  });\n  return res;\n};\n\nconst clusteringIndividual = (g, node) => {\n  const neighbors = g.adjList.get(node);\n  // number of edges between neighbors\n  const numNeighbors = neighbors.length;\n  // calculates total possible number of pairs, i.e. n choose 2\n  const numPairs = factorial(numNeighbors) / (factorial(numNeighbors - 2) * 2);\n\n  // for each pair of nodes, check to see if there is edge between\n  let count = 0;\n  neighbors.forEach(({ node: neighborId, weight }) => {\n    neighbors.forEach(({ node: neighborId2, weight2 }) => {\n      if (neighborId !== neighborId2) {\n        const nodes = g.adjList.get(neighborId);\n        nodes.forEach(({ node: neighborId3, weight3 }) => {\n          count += neighborId3 === neighborId2 ? 1 : 0;\n        });\n      }\n    });\n  });\n\n  // divide by 2 if undirected\n  const numEdges = count / (g.state.undirected ? 2.0 : 1.0);\n  const denom = g.state.undirected\n    ? numPairs\n    : numNeighbors * (numNeighbors - 1);\n  return denom !== 0 ? numEdges / denom : 0;\n};\n\n// calculates factorial, used in calculation of all possible pairs\nfunction factorial(num) {\n  if (num === 0 || num === 1) {\n    return 1;\n  }\n  for (var i = num - 1; i > 0; i--) {\n    num *= i;\n  }\n  return num;\n}\n\nexport default clusteringCoefficient;\n","// start - node to start DFS from\n// only visits nodes reachable from start (NOT full traversal)\nconst dfs = (g, start) => {\n\t// stack for iterative DFS\n\tconst stack = [];\n\t// array of nodes to return\n\tconst result = [];\n\t// set of discovered nodes\n\tconst discovered = new Set();\n\t// initialize by adding start node\n\tstack.push(start);\n\n\twhile (stack.length !== 0) {\n\t\t// pop stack, look at node's neighbors\n\t\tconst curr = stack.pop();\n\t\tconst outneighbors = g.adjList.get(curr);\n\n\t\t// if we haven't seen this node, add the node\n\t\tif (!discovered.has(curr)) {\n\t\t\tresult.push(curr);\n\t\t\tdiscovered.add(curr);\n\t\t}\n\n\t\t// add each neighbor of current node to stack\n\t\toutneighbors.forEach(({ node, weight }) => {\n\t\t\tif (!discovered.has(node)) {\n\t\t\t\tstack.push(node);\n\t\t\t}\n\t\t});\n\t}\n\n\treturn result;\n};\n\nexport default dfs;\n","// calculates shortest paths from start node to ALL other nodes via Dijkstra's algorithm\nconst dijkstra = (g, start) => {\n\t// map to store current distances from start node\n\tconst distances = new Map();\n\t// store each node with its minimum distance from the start\n\tconst res = [];\n\t// initialize distances to infinity for all nodes except start\n\tg.adjList.forEach((value, node) => distances.set(node, Number.MAX_VALUE));\n\tdistances.set(start, 0);\n\n\t// max is number of keys\n\tlet numIterations = 0;\n\tconst maxSize = g.adjList.size;\n\twhile (numIterations++ < maxSize) {\n\t\tlet minDist = Number.MAX_VALUE;\n\t\tlet minNode = -1;\n\t\tdistances.forEach((val, key) => {\n\t\t\t// update minimum distance and node\n\t\t\tif (val < minDist) {\n\t\t\t\tminNode = key;\n\t\t\t\tminDist = val;\n\t\t\t}\n\t\t});\n\t\tif (minNode >= 0) {\n\t\t\tres.push({ node: minNode, distance: minDist });\n\t\t\tdistances.delete(minNode);\n\t\t\t// update distance if less than running minimum distance\n\t\t\tg.adjList.get(minNode).forEach(({ node, weight }) => {\n\t\t\t\tdistances.set(node, Math.min(distances.get(node), minDist + weight));\n\t\t\t});\n\t\t}\n\t}\n\treturn res;\n};\n\nexport default dijkstra;\n","// Tarjan's algorithm (full recursive DFS traversal)\nconst topoSort = (g) => {\n\t// stack of nodes to return in order of decreasing finish timed\n\tconst finished = [];\n\t// map of node to color (0 is undiscovered, 1 is discovered, 2 is finished)\n\tconst color = new Map();\n\tlet valid = true;\n\n\t// initialize color of each node to 0 (undiscovered)\n\tg.adjList.forEach((values, node) => {\n\t\tcolor.set(node, 0);\n\t});\n\n\tg.adjList.forEach((values, node) => {\n\t\t// if undiscovered, visit node\n\t\tif (color.get(node) === 0) {\n\t\t\tif (!dfsVisit(g, node, color, finished)) {\n\t\t\t\tvalid = false;\n\t\t\t}\n\t\t}\n\t});\n\t// return nodes in decreasing order of finish times\n\treturn { valid: valid, res: finished.reverse() };\n};\n\n// DFS helper method\nfunction dfsVisit(g, node, color, finished) {\n\tcolor.set(node, 1);\n\t// iterate through neighbors\n\tconst neighbors = g.adjList.get(node);\n\tlet valid = true;\n\tneighbors.forEach(({ node: v, weight }) => {\n\t\t// found back edge, which implies cycle exists so no valid topo sort\n\t\tif (color.get(v) === 1) {\n\t\t\tvalid = false;\n\t\t}\n\n\t\t// if node undiscovered and no cycles have been found, visit node\n\t\tif (color.get(v) === 0) {\n\t\t\tif (!dfsVisit(g, v, color, finished)) {\n\t\t\t\tvalid = false;\n\t\t\t}\n\t\t}\n\t});\n\n\t// finish node\n\tcolor.set(node, 2);\n\t// push node to stack once finished\n\tfinished.push(node);\n\treturn valid;\n}\n\nexport default topoSort;\n","// returns a Set of obj {NodeA, NodeB}, which represents edges formed\n// Note: if edge forms between NodeA and NodeB, output set will contain\n// {NodeA, NodeB} and {NodeB, NodeA}\nconst triadicClosure = (g) => {\n  const res = new Set();\n\n  /* \n    Iterate through neighbors of A and B.\n    If node A and node B share a neighbor, \n    by triadic closure, an edge between A \n    and B will likely form, so add it to set. \n   */\n  g.adjList.forEach((neighborsA, nodeA) => {\n    g.adjList.forEach((neighborsB, nodeB) => {\n      if (\n        nodeA !== nodeB &&\n        shareNeighbor(neighborsA, neighborsB) &&\n        !includesNode(\n          neighborsA,\n          nodeB\n        ) /* nodeA's neighbors does not include nodeB */\n      ) {\n        res.add({ NodeA: nodeA, NodeB: nodeB });\n      }\n    });\n  });\n  return res;\n};\n\n// check if list of neighbors includes node\nconst includesNode = (neighborsA, nodeB) => {\n  var included = false;\n  neighborsA.forEach(({ node: nodeA, weight }) => {\n    if (nodeA === nodeB) {\n      included = true;\n    }\n  });\n  return included;\n};\n\n// check if two nodes have a common neighbor\nconst shareNeighbor = (neighborsA, neighborsB) => {\n  var shared = false;\n  neighborsA.forEach((neighborA) => {\n    if (neighborsB.some((neighborB) => neighborA.node === neighborB.node)) {\n      shared = true;\n    }\n  });\n  return shared;\n};\n\nexport default triadicClosure;\n","import React, { Component } from \"react\";\nimport Draggable from \"react-draggable\"; // Both at the same time\nimport Xarrow from \"react-xarrows\";\nimport Results from \"./Results\";\n\nimport bfs from \"../algos/bfs\";\nimport bridges from \"../algos/bridges\";\nimport clusteringCoefficient from \"../algos/clusteringCoefficient\";\nimport dfs from \"../algos/dfs\";\nimport dijkstra from \"../algos/dijkstra\";\nimport topoSort from \"../algos/topoSort\";\nimport triadicClosure from \"../algos/triadicClosure\";\n\n// dimensions for nodes\nconst DIM = 62.5;\n\n// styles for drawing nodes\nconst circleStyle = (selected, x, y) => {\n  return {\n    padding: 0,\n    margin: 10,\n    position: \"absolute\",\n    backgroundColor: selected ? \"#ffd3b4\" : \"#98ddca\",\n    borderRadius: \"50%\",\n    border: \"2px solid black\",\n    width: DIM,\n    height: DIM,\n    lineHeight: `${DIM}px`,\n    left: `${x - DIM / 2}px`,\n    top: `${y - DIM / 2}px`,\n    outlineWidth: 0,\n  };\n};\n\n// toggles color of edges if selected\nconst edgeColor = (selected) => {\n  return selected ? \"#ffd3b4\" : \"#98ddca\";\n};\n\n// initial state for graph canvas\nconst initialState = (props) => {\n  return {\n    nextId: 0,\n    selectedId: -1,\n    selectedEdge: { a: -1, b: -1 },\n    undirected: props.selectedType === \"undirected\",\n    unweighted: props.selectedWeight === \"unweighted\",\n    algorithm: props.algorithm,\n    cleared: props.cleared,\n    results: props.result ? props.result : \"\",\n    open: false,\n  };\n};\n\nclass Graph extends Component {\n  constructor(props) {\n    super(props);\n    // maps node to object with node as key and edge weight as value\n    this.adjList = new Map();\n    this.nodeToElement = new Map();\n    // set initial state\n    this.state = initialState(props);\n\n    this.getClickCoords = this.getClickCoords.bind(this);\n    this.addNode = this.addNode.bind(this);\n    this.selectNode = this.selectNode.bind(this);\n    this.addEdge = this.addEdge.bind(this);\n  }\n\n  shouldComponentUpdate(nextProps) {\n    // condition to updated weight and directionality\n    let updated = false;\n    if (\n      (nextProps.selectedType === \"undirected\") !== this.state.undirected ||\n      (nextProps.selectedWeight === \"unweighted\") !== this.state.unweighted\n    ) {\n      if (\n        (nextProps.selectedType === \"undirected\") !== this.state.undirected &&\n        !this.state.undirected\n      ) {\n        this.adjList.forEach((neighbors, id) => {\n          neighbors.forEach(({ node, weight }) => {\n            this.addEdge(node, id, weight);\n          });\n        });\n      }\n      this.setState({\n        undirected: nextProps.selectedType === \"undirected\",\n        unweighted: nextProps.selectedWeight === \"unweighted\",\n      });\n      updated = true;\n    }\n\n    // condition to update clear\n    if (this.state.cleared !== nextProps.cleared) {\n      this.adjList = new Map();\n      this.nodeToElement = new Map();\n      this.setState(initialState(nextProps));\n      updated = true;\n    }\n\n    // condition to run algorithm\n    if (\n      this.state.algorithm !== nextProps.selectedAlgorithm ||\n      this.state.changed\n    ) {\n      let result;\n      switch (nextProps.selectedAlgorithm) {\n        case \"bfs\":\n          // run bfs\n          if (this.state.selectedId >= 0) {\n            result = bfs(this, this.state.selectedId);\n          }\n          break;\n        case \"dfs\":\n          // run dfs\n          if (this.state.selectedId >= 0) {\n            result = dfs(this, this.state.selectedId);\n          }\n          break;\n        case \"dijkstra\":\n          // run dijkstra\n          if (this.state.selectedId >= 0) {\n            result = dijkstra(this, this.state.selectedId);\n          }\n          break;\n        case \"topo sort\":\n          // run topo sort\n          result = topoSort(this);\n          break;\n        case \"clustering\":\n          // run clustering\n          if (this.state.selectedId >= 0) {\n            result = clusteringCoefficient(this, this.state.selectedId);\n          }\n          break;\n        case \"bridges\":\n          // run bridges\n          result = bridges(this);\n          break;\n        case \"triadic\":\n          // run triadic\n          result = triadicClosure(this);\n          break;\n        default:\n          break;\n      }\n      // update state based on current algorithm and result\n      this.setState({\n        results: result,\n        algorithm: nextProps.selectedAlgorithm,\n        changed: false,\n      });\n      this.forceUpdate();\n      updated = true;\n    }\n    return updated;\n  }\n\n  // get mouse click coordinates\n  getClickCoords = (event) => {\n    // from: https://stackoverflow.com/a/29296049/14198287\n    var e = event.target;\n    var dim = e.getBoundingClientRect();\n    var x = event.clientX - dim.left;\n    var y = event.clientY - dim.top;\n    return [x, y];\n  };\n\n  // adds a node to the graph, if it doesn't already exist\n  // does nothing if node already in graph\n  addNode = (e, id) => {\n    if (!this.adjList.has(id)) {\n      this.adjList.set(id, []);\n\n      const [x, y] = this.getClickCoords(e);\n      this.nodeToElement.set(id, () => (\n        <Draggable\n          bounds=\"parent\"\n          key={id}\n          onDrag={(e, ui) => {\n            this.setState({ changed: true });\n            this.forceUpdate();\n          }}\n        >\n          <div\n            tabIndex=\"1\"\n            onKeyDown={(e) => {\n              if (e.key === \"Backspace\" || e.key === \"Delete\") {\n                this.removeNode(id);\n              }\n            }}\n            style={circleStyle(this.state.selectedId === id, x, y)}\n            onClick={(e) => {\n              if (e.shiftKey) {\n                this.addEdge(this.state.selectedId, id, 1);\n              } else {\n                this.selectNode(e, id);\n              }\n              this.forceUpdate();\n            }}\n            className={`Node${id}`}\n            id={`Node${id}`}\n          >\n            {id}\n          </div>\n        </Draggable>\n      ));\n\n      this.setState({ selectedId: id }, () => {\n        this.forceUpdate();\n      });\n    }\n    return this;\n  };\n\n  // remove node if it's in the graph\n  // no effect if node isn't in graph\n  removeNode = (id) => {\n    // remove from lists of neighbors\n    this.adjList.forEach((neighbors, node) => {\n      this.adjList.set(\n        node,\n        neighbors.filter((val) => val !== id)\n      );\n\n      // remove entry in adjacency list\n      this.adjList.delete(id);\n      this.nodeToElement.delete(id);\n    });\n    this.forceUpdate();\n    return this;\n  };\n\n  // props = {out: number, in: number, weight: number}\n  addEdge = (outNode, inNode, weight) => {\n    if (this.adjList.has(outNode) && this.adjList.has(inNode)) {\n      this.adjList.set(outNode, [\n        ...this.adjList.get(outNode).filter((obj) => obj.node !== inNode),\n        { node: inNode, weight: weight },\n      ]);\n      if (this.state.undirected) {\n        this.adjList.set(inNode, [\n          ...this.adjList.get(inNode).filter((obj) => obj.node !== outNode),\n          { node: outNode, weight: weight },\n        ]);\n      }\n      this.setState(\n        {\n          changed: true,\n          selectedId: inNode,\n        },\n        () => {\n          this.shouldComponentUpdate({\n            cleared: this.state.cleared,\n            selectedType: this.state.undirected ? \"undirected\" : \"directed\",\n            selectedWeight: this.state.unweighted ? \"unweighted\" : \"weighted\",\n            selectedAlgorithm: this.state.algorithm,\n          });\n        }\n      );\n    }\n    this.forceUpdate();\n    return this;\n  };\n\n  // props = {out: number, in: number}\n  removeEdge = (outNode, inNode) => {\n    if (this.adjList.has(outNode)) {\n      this.adjList.set(\n        outNode,\n        this.adjList.get(outNode).filter((obj) => obj.node !== inNode)\n      );\n      if (this.state.undirected) {\n        this.adjList.set(\n          inNode,\n          this.adjList.get(inNode).filter((obj) => obj.node !== outNode)\n        );\n      }\n    }\n    this.forceUpdate();\n    return this;\n  };\n\n  selectNode = (e, id) => {\n    this.setState(\n      {\n        selectedId: id,\n        selectedEdge: { a: -1, b: -1 },\n        changed: true,\n      },\n      () => {\n        this.shouldComponentUpdate({\n          cleared: this.state.cleared,\n          selectedType: this.state.undirected ? \"undirected\" : \"directed\",\n          selectedWeight: this.state.unweighted ? \"unweighted\" : \"weighted\",\n          selectedAlgorithm: this.state.algorithm,\n        });\n      }\n    );\n\n    this.forceUpdate();\n    e.stopPropagation();\n  };\n\n  render() {\n    const nodes = [];\n    const it = this.nodeToElement.values();\n    let res = it.next();\n    while (!res.done) {\n      nodes.push(res.value());\n      res = it.next();\n    }\n    const edges = [];\n    const drawnEdges = [];\n    this.adjList.forEach((neighbors, id) => {\n      neighbors.forEach((neighbor) => {\n        if (\n          !this.state.undirected ||\n          !drawnEdges.some(\n            ({ inNode, outNode }) => inNode === neighbor.node && outNode === id\n          )\n        ) {\n          drawnEdges.push({ inNode: id, outNode: neighbor.node });\n          edges.push(\n            <Xarrow\n              key={`Node${id}-Node${neighbor.node}`}\n              start={`Node${id}`}\n              end={`Node${neighbor.node}`}\n              label={!this.state.unweighted ? `${neighbor.weight}` : \"\"}\n              showHead={!this.state.undirected}\n              color={edgeColor(\n                this.state.selectedEdge.a === id &&\n                  this.state.selectedEdge.b === neighbor.node\n              )}\n              strokeWidth={5}\n              onClick={(e) => {\n                this.setState({\n                  selectedId: -1,\n                  selectedEdge: { a: id, b: neighbor.node },\n                });\n                e.stopPropagation();\n                this.forceUpdate();\n              }}\n              tabIndex=\"1\"\n              onKeyDown={(e) => {\n                if (e.key === \"Backspace\" || e.key === \"Delete\") {\n                  this.removeEdge(id, neighbor.node);\n                  this.setState({\n                    selectedEdge: { a: -1, b: -1 },\n                  });\n                } else if (e.key === \"Enter\") {\n                  this.removeEdge(id, neighbor.node);\n                  this.addEdge(id, neighbor.node, 0);\n                } else if (\n                  e.key === \"0\" ||\n                  e.key === \"1\" ||\n                  e.key === \"2\" ||\n                  e.key === \"3\" ||\n                  e.key === \"4\" ||\n                  e.key === \"5\" ||\n                  e.key === \"6\" ||\n                  e.key === \"7\" ||\n                  e.key === \"8\" ||\n                  e.key === \"9\"\n                ) {\n                  let edgeWeight = 1;\n                  this.adjList\n                    .get(id)\n                    .forEach(\n                      ({ node, weight }) =>\n                        (edgeWeight =\n                          node === neighbor.node ? weight : edgeWeight)\n                    );\n                  this.removeEdge(id, neighbor.node);\n                  this.addEdge(\n                    id,\n                    neighbor.node,\n                    edgeWeight * 10 + parseInt(e.key)\n                  );\n\n                  this.forceUpdate();\n                }\n                this.setState({ changed: true });\n              }}\n            />\n          );\n        }\n      });\n    });\n\n    const dottedEdges = [];\n    const drawnDottedEdges = [];\n    if (this.state.algorithm === \"triadic\") {\n      this.state.results.forEach(({ NodeA, NodeB }) => {\n        if (\n          !this.state.undirected ||\n          !drawnDottedEdges.some(\n            ({ inNode, outNode }) => inNode === NodeB && outNode === NodeA\n          )\n        ) {\n          drawnDottedEdges.push({ inNode: NodeA, outNode: NodeB });\n          dottedEdges.push(\n            <Xarrow\n              key={`Node${NodeA}-Node${NodeB}`}\n              start={`Node${NodeA}`}\n              end={`Node${NodeB}`}\n              label={\"\"}\n              showHead={!this.state.undirected}\n              color={\"#98ddca\"}\n              strokeWidth={5}\n              dashness={{ strokeLen: 10, nonStrokeLen: 10 }}\n            />\n          );\n        }\n      });\n    }\n\n    return (\n      <div\n        onClick={() => {\n          this.setState({\n            selectedId: -1,\n            selectedEdge: { a: -1, b: -1 },\n            //\n          });\n          this.forceUpdate();\n        }}\n        onDoubleClick={(e) => {\n          if (\n            this.state.selectedId < 0 &&\n            this.state.selectedEdge.a === -1 &&\n            this.state.selectedEdge.b === -1\n          ) {\n            this.addNode(e, this.state.nextId);\n            this.setState({\n              nextId: this.state.nextId + 1,\n              selectedEdge: { a: -1, b: -1 },\n            });\n            this.forceUpdate();\n          }\n        }}\n        className=\"canvas\"\n      >\n        <div className=\"graph\">\n          {dottedEdges}\n          {edges}\n          {nodes}\n        </div>\n        <Results result={this.state.results} algorithm={this.state.algorithm} />\n      </div>\n    );\n  }\n}\n\nexport default Graph;\n","import React, { useState } from \"react\";\nimport Button from \"@material-ui/core/Button\";\nimport Radio from \"@material-ui/core/Radio\";\nimport RadioGroup from \"@material-ui/core/RadioGroup\";\nimport FormControlLabel from \"@material-ui/core/FormControlLabel\";\nimport FormControl from \"@material-ui/core/FormControl\";\nimport Dialog from \"@material-ui/core/Dialog\";\nimport DialogActions from \"@material-ui/core/DialogActions\";\nimport DialogContent from \"@material-ui/core/DialogContent\";\nimport DialogContentText from \"@material-ui/core/DialogContentText\";\nimport DialogTitle from \"@material-ui/core/DialogTitle\";\n\n// bottom toolbar for running algorithms, clearing graph, and viewing instructions\nconst Toolbar = ({\n  selectedType,\n  setSelectedType,\n  selectedWeight,\n  setSelectedWeight,\n  setSelectedAlgorithm,\n  setCleared,\n  cleared,\n}) => {\n  const instructionsText = (\n    <>\n      Double click to add a node. Single click to select a node or edge.\n      <br />\n      After selecting a node, shift click on another node to add an edge.\n      <br />\n      To delete a node or edge, select the node/edge and then hit the{\" \"}\n      <code>backspace</code> or <code>delete</code> key on your keyboard.\n      <br />\n      <br />\n      The default edge weight is 1. To change an edge weight, first press{\" \"}\n      <code>enter</code> to set the edge weight to 0. Then, type in any number\n      to append the digits to the edge weight.\n      <br />\n      <br />\n      Also, note that for some algorithms (BFS, DFS, and Dijkstra), a node must\n      be selected in order to run the algorithm. Once run, the algorithm's\n      results will be displayed in the Results pane on the right side of the\n      screen.\n    </>\n  );\n\n  // state for dialog box for instructions\n  const [open, setOpen] = useState(false);\n\n  // open dialog\n  const handleClickOpen = () => {\n    setOpen(true);\n  };\n\n  // close dialog\n  const handleClose = () => {\n    setOpen(false);\n  };\n\n  // disable buttons based on current graph specifications\n  const isDisabled = (alg) => {\n    if (\n      alg === \"bfs\" ||\n      alg === \"dfs\" ||\n      alg === \"dijkstra\" ||\n      alg === \"clustering\"\n    ) {\n      return false;\n    } else if (alg === \"bridges\") {\n      return selectedType !== \"undirected\";\n    } else if (alg === \"topo sort\") {\n      return selectedType !== \"directed\";\n    } else {\n      return false;\n    }\n  };\n\n  // manage radio button state\n  const handleChange = (e, type) => {\n    switch (type) {\n      case \"direction\":\n        setSelectedType(e.target.value);\n        break;\n      case \"weight\":\n        setSelectedWeight(e.target.value);\n        break;\n      default:\n        console.log(\"Invalid type\");\n        break;\n    }\n  };\n\n  // render toolbar\n  return (\n    <div className=\"toolbar\">\n      <div className=\"button-group\">\n        <div className=\"btn\">\n          <Button variant=\"contained\" onClick={handleClickOpen}>\n            Instructions\n          </Button>\n          <Dialog\n            open={open}\n            onClose={handleClose}\n            aria-labelledby=\"alert-dialog-title\"\n            aria-describedby=\"alert-dialog-description\"\n          >\n            <DialogTitle id=\"alert-dialog-title\">{\"Instructions\"}</DialogTitle>\n            <DialogContent>\n              <DialogContentText id=\"alert-dialog-description\">\n                {instructionsText}\n              </DialogContentText>\n            </DialogContent>\n            <DialogActions>\n              <Button onClick={handleClose} color=\"primary\" autoFocus>\n                Cancel\n              </Button>\n            </DialogActions>\n          </Dialog>\n        </div>\n        <div className=\"btn\">\n          <Button\n            variant=\"outlined\"\n            onClick={() => setSelectedAlgorithm(\"bfs\")}\n            disabled={isDisabled(\"bfs\")}\n          >\n            BFS\n          </Button>\n        </div>\n        <div className=\"btn\">\n          <Button\n            variant=\"outlined\"\n            onClick={(e) => setSelectedAlgorithm(\"dfs\")}\n            disabled={isDisabled(\"dfs\")}\n          >\n            DFS\n          </Button>\n        </div>\n        <div className=\"btn\">\n          <Button\n            variant=\"outlined\"\n            onClick={(e) => setSelectedAlgorithm(\"dijkstra\")}\n            disabled={isDisabled(\"dijkstra\")}\n          >\n            Dijkstra\n          </Button>\n        </div>\n        <div className=\"btn\">\n          <Button\n            variant=\"outlined\"\n            onClick={(e) => setSelectedAlgorithm(\"topo sort\")}\n            disabled={isDisabled(\"topo sort\")}\n          >\n            Topo Sort\n          </Button>\n        </div>\n        <div className=\"btn\">\n          <Button\n            variant=\"outlined\"\n            onClick={(e) => setSelectedAlgorithm(\"clustering\")}\n            disabled={isDisabled(\"clustering\")}\n          >\n            Clustering Coefficient\n          </Button>\n        </div>\n        <div className=\"btn\">\n          <Button\n            variant=\"outlined\"\n            onClick={(e) => setSelectedAlgorithm(\"bridges\")}\n            disabled={isDisabled(\"bridges\")}\n          >\n            Bridges\n          </Button>\n        </div>\n        <div className=\"btn\">\n          <Button\n            variant=\"outlined\"\n            onClick={(e) => setSelectedAlgorithm(\"triadic\")}\n            disabled={isDisabled(\"triadic\")}\n          >\n            Triadic Closure\n          </Button>\n        </div>\n        <div className=\"btn\">\n          <Button\n            variant=\"contained\"\n            color=\"secondary\"\n            onClick={() => {\n              setCleared(!cleared);\n              setSelectedAlgorithm(\"\");\n            }}\n          >\n            CLEAR\n          </Button>\n        </div>\n      </div>\n      <FormControl component=\"fieldset\">\n        <RadioGroup\n          aria-label=\"graph-type\"\n          name=\"controlled-radio-buttons-group\"\n          value={selectedType}\n          onChange={(e) => handleChange(e, \"direction\")}\n        >\n          <FormControlLabel\n            value=\"undirected\"\n            control={<Radio color=\"primary\" />}\n            label=\"Undirected\"\n          />\n          <FormControlLabel\n            value=\"directed\"\n            control={<Radio color=\"primary\" />}\n            label=\"Directed\"\n          />\n        </RadioGroup>\n      </FormControl>\n\n      <FormControl component=\"fieldset\">\n        <RadioGroup\n          aria-label=\"edge-type\"\n          name=\"controlled-radio-buttons-group\"\n          value={selectedWeight}\n          onChange={(e) => handleChange(e, \"weight\")}\n        >\n          <FormControlLabel\n            value=\"unweighted\"\n            control={<Radio color=\"primary\" />}\n            label=\"Unweighted\"\n          />\n          <FormControlLabel\n            value=\"weighted\"\n            control={<Radio color=\"primary\" />}\n            label=\"Weighted\"\n          />\n        </RadioGroup>\n      </FormControl>\n    </div>\n  );\n};\n\nexport default Toolbar;\n","import React, { useState } from \"react\";\nimport \"./App.css\";\nimport Graph from \"./components/Graph\";\nimport Toolbar from \"./components/Toolbar\";\n\nfunction App() {\n\t// state for undirected vs directed graph\n\tconst [selectedType, setSelectedType] = useState(\"undirected\");\n\t// state for unweighted vs weighted graph\n\tconst [selectedWeight, setSelectedWeight] = useState(\"unweighted\");\n\t// state for selected algorithm\n\tconst [selectedAlgorithm, setSelectedAlgorithm] = useState(\"\");\n\t// state for whether or not graph is cleared\n\tconst [cleared, setCleared] = useState(false);\n\n\treturn (\n\t\t<div className=\"app\">\n\t\t\t<Graph\n\t\t\t\tselectedType={selectedType}\n\t\t\t\tselectedWeight={selectedWeight}\n\t\t\t\tselectedAlgorithm={selectedAlgorithm}\n\t\t\t\tcleared={cleared}\n\t\t\t/>\n\t\t\t<Toolbar\n\t\t\t\tselectedType={selectedType}\n\t\t\t\tsetSelectedType={setSelectedType}\n\t\t\t\tselectedWeight={selectedWeight}\n\t\t\t\tsetSelectedWeight={setSelectedWeight}\n\t\t\t\tsetSelectedAlgorithm={setSelectedAlgorithm}\n\t\t\t\tcleared={cleared}\n\t\t\t\tsetCleared={setCleared}\n\t\t\t/>\n\t\t</div>\n\t);\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}