{"version":3,"sources":["components/Results.jsx","algos/bfs.js","algos/bridges.js","algos/clusteringCoefficient.js","algos/dfs.js","algos/dijkstra.js","algos/topoSort.js","algos/triadicClosure.js","components/Graph.jsx","components/Toolbar.jsx","App.js","index.js"],"names":["emptyResults","className","resultsToText","result","algorithm","separator","bfsString","frontierCount","push","forEach","frontier","sort","a","b","currString","node","slice","lastIndexOf","dfsString","dijkstraString","distance","topoString","valid","res","clusteringString","cc","toFixed","bridgesString","size","node1","node2","triadicString","NodeA","NodeB","Results","undefined","bfs","g","start","seen","Set","queue","tempQueue","parent","add","adjList","get","weight","includes","has","length","dfsVisit","time","u","visited","discovered","low","bridges","v","Math","min","values","clusteringIndividual","neighbors","numNeighbors","numPairs","factorial","count","neighborId","neighborId2","weight2","neighborId3","weight3","num","i","clusteringCoefficient","dfs","stack","curr","pop","outneighbors","dijkstra","distances","Map","value","set","Number","MAX_VALUE","numIterations","maxSize","minDist","minNode","val","key","delete","color","finished","topoSort","reverse","includesNode","neighborsA","nodeB","included","nodeA","shareNeighbor","neighborsB","shared","neighborA","some","neighborB","triadicClosure","DIM","circleStyle","selected","x","y","padding","margin","position","backgroundColor","borderRadius","border","width","height","lineHeight","left","top","outlineWidth","initialState","props","nextId","selectedId","selectedEdge","undirected","selectedType","unweighted","selectedWeight","cleared","results","open","Graph","getClickCoords","event","dim","target","getBoundingClientRect","clientX","clientY","addNode","e","id","nodeToElement","bounds","onDrag","ui","setState","changed","forceUpdate","tabIndex","onKeyDown","removeNode","style","state","onClick","shiftKey","addEdge","selectNode","filter","outNode","inNode","obj","shouldComponentUpdate","selectedAlgorithm","removeEdge","stopPropagation","bind","nextProps","updated","this","nodes","it","next","done","edges","drawnEdges","neighbor","end","label","showHead","strokeWidth","edgeWeight","parseInt","dottedEdges","drawnDottedEdges","dashness","strokeLen","nonStrokeLen","onDoubleClick","Component","Toolbar","setSelectedType","setSelectedWeight","setSelectedAlgorithm","setCleared","instructionsText","useState","setOpen","handleClose","isDisabled","alg","handleChange","type","console","log","Button","variant","Dialog","onClose","aria-labelledby","aria-describedby","DialogTitle","DialogContent","DialogContentText","DialogActions","autoFocus","disabled","FormControl","component","RadioGroup","aria-label","name","onChange","FormControlLabel","control","Radio","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.9663f99d.chunk.js","sourcesContent":["import React from \"react\";\n\nconst emptyResults = (\n  <div className=\"results\">\n    <h2 className=\"results-heading\">Results</h2>\n    <div className=\"output-window\">Click on an algorithm to get started!</div>\n  </div>\n);\n\nconst resultsToText = (result, algorithm) => {\n  const separator = \"----------\";\n  switch (algorithm) {\n    case \"bfs\":\n      let bfsString = [];\n      var frontierCount = 0;\n      bfsString.push(`Source Node: Node${result[0][0]}`);\n      result.forEach((frontier) => {\n        frontier = frontier.sort(function (a, b) {\n          return a - b;\n        });\n        let currString = `Frontier ${frontierCount++}: `;\n        frontier.forEach((node) => (currString += `Node${node}, `));\n        currString = currString.slice(0, currString.lastIndexOf(\",\")); // slice off last \", \"\n        bfsString.push(\n          <div key={frontierCount}>\n            - {currString}\n            <br />\n          </div>\n        );\n      });\n      return (\n        <>\n          BFS\n          <br />\n          {separator}\n          <br />\n          {bfsString}\n        </>\n      );\n    case \"dfs\":\n      let dfsString = [];\n      result.forEach((node) =>\n        dfsString.push(\n          <div key={node}>\n            - Node{node}\n            <br />\n          </div>\n        )\n      );\n      return (\n        <>\n          DFS\n          <br />\n          {separator}\n          <br />\n          Order of Nodes Visited:\n          <br />\n          {dfsString}\n        </>\n      );\n    case \"dijkstra\":\n      let dijkstraString = [];\n      result.forEach(({ node, distance }) => {\n        dijkstraString.push(\n          <div key={`Node${node}: ${distance} units`}>\n            - Node{node}: {distance} units\n            <br />\n          </div>\n        );\n      });\n      return (\n        <>\n          Dijkstra\n          <br />\n          {separator}\n          <br />\n          Shortest distances from Node{result[0].node}:\n          <br />\n          {dijkstraString}\n        </>\n      );\n    case \"topo sort\":\n      let topoString = [];\n      if (!result.valid) {\n        topoString.push(\"No valid topo sort, graph cannot have cycle.\");\n      } else {\n        topoString.push(\n          <>\n            One potential ordering:\n            <br />\n          </>\n        );\n        result.res.forEach((node) => {\n          topoString.push(\n            <div key={node}>\n              - Node{node}\n              <br />\n            </div>\n          );\n        });\n      }\n      return (\n        <>\n          Topological Sort\n          <br />\n          {separator}\n          <br />\n          {topoString}\n        </>\n      );\n    case \"clustering\":\n      let clusteringString = [];\n      result.forEach(({ node, cc }) => {\n        clusteringString.push(\n          <div key={node}>\n            - Node{node}: {cc.toFixed(2)}\n            <br />\n          </div>\n        );\n      });\n      return (\n        <>\n          Clustering Coefficient\n          <br />\n          {separator}\n          <br />\n          {clusteringString}\n        </>\n      );\n    case \"bridges\":\n      let bridgesString = [];\n      if (result.size === 0) {\n        bridgesString.push(\"No global bridges found.\");\n      } else {\n        bridgesString.push(\n          <div>\n            Global Bridges:\n            <br />\n          </div>\n        );\n        result.forEach(({ node1, node2 }) => {\n          bridgesString.push(\n            <div key={`Node${node1} -> Node${node2}`}>\n              - Node{node1} {\"<->\"} Node{node2}\n              <br />\n            </div>\n          );\n        });\n      }\n      return (\n        <>\n          Global Bridges\n          <br />\n          {separator}\n          <br />\n          {bridgesString}\n        </>\n      );\n    case \"triadic\":\n      let triadicString = [];\n      if (result.size === 0) {\n        triadicString.push(\n          <div>\n            No new edges would be formed due to Triadic Closure.\n            <br />\n          </div>\n        );\n      } else {\n        triadicString.push(\n          <div>\n            New Edges Formed due to Triadic Closure:\n            <br />\n          </div>\n        );\n        result.forEach(({ NodeA, NodeB }) => {\n          triadicString.push(\n            <div key={`Node${NodeA} -> Node${NodeB}`}>\n              - Node{NodeA} {\"->\"} Node{NodeB}\n              <br />\n            </div>\n          );\n        });\n      }\n      return (\n        <>\n          Triadic Closure\n          <br />\n          {separator}\n          <br />\n          {triadicString}\n        </>\n      );\n    default:\n      return \"\";\n  }\n};\n\nconst Results = ({ result, algorithm }) => {\n  const emptyCondition =\n    result === undefined || algorithm === undefined || algorithm === \"\";\n  return emptyCondition ? (\n    emptyResults\n  ) : (\n    <div className=\"results\">\n      <h2 className=\"results-heading\">Results</h2>\n      <div className=\"output-window\">{resultsToText(result, algorithm)}</div>\n    </div>\n  );\n};\n\nexport default Results;\n","// performs full BFS traversal from given start node\nconst bfs = (g, start) => {\n\tconst seen = new Set();\n\t// queue for BFS\n\tlet queue = [start];\n\t// list of lists to store each layer/frontier of BFS traversal\n\tlet res = [];\n\t// while queue is not empty, proceed\n\twhile (queue.length !== 0) {\n\t\t// add current layer/frontier\n\t\tres.push([...queue]);\n\t\tlet tempQueue = [];\n\t\t// mark all parents as seen / discovered\n\t\tqueue.forEach((parent) => {\n\t\t\tseen.add(parent);\n\t\t});\n\t\t// add next layer/frontier of nodes to queue if we haven't seen it already\n\t\tqueue.forEach((parent) => {\n\t\t\tg.adjList.get(parent).forEach(({ node, weight }) => {\n\t\t\t\tif (!tempQueue.includes(node) && !seen.has(node)) {\n\t\t\t\t\ttempQueue.push(node);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\t// update queue\n\t\tqueue = [...tempQueue];\n\t}\n\treturn res;\n};\n\nexport default bfs;\n","/* Algorithm using modified DFS traversal to find all edges\nthat disconnect an UNDIRECTED graph (i.e. global bridges) */\n// Reference: https://www.geeksforgeeks.org/bridge-in-a-graph/\nconst bridges = (g) => {\n\tlet time = 0;\n\n\t// store edges that are bridges\n\tlet bridges = new Set();\n\t// stores which nodes have been visited in DFS\n\tlet visited = new Set();\n\t// maps nodes to parent nodes in DFS tree\n\tlet parent = {};\n\t// map nodes to discovery time\n\tlet discovered = {};\n\t// map indicating whether some node discovered earlier\n\t// can be visited by subtree rooted at that node\n\tlet low = {};\n\n\tg.adjList.forEach((values, node) => {\n\t\tif (!visited.has(node)) {\n\t\t\tdfsVisit(g, time, node, visited, discovered, low, parent, bridges);\n\t\t}\n\t});\n\n\treturn bridges;\n};\n\n// DFS helper method\nfunction dfsVisit(g, time, u, visited, discovered, low, parent, bridges) {\n\ttime++;\n\tvisited.add(u);\n\tdiscovered[u] = time;\n\tlow[u] = time;\n\n\t// iterate through neighbors\n\tconst neighbors = g.adjList.get(u);\n\tneighbors.forEach(({ node: v, weight }) => {\n\t\tif (!visited.has(v)) {\n\t\t\tparent[v] = u;\n\t\t\tdfsVisit(g, time, v, visited, discovered, low, parent, bridges);\n\t\t\tlow[u] = Math.min(low[u], low[v]);\n\n\t\t\tif (low[v] > discovered[u]) {\n\t\t\t\tbridges.add({ node1: u, node2: v });\n\t\t\t}\n\t\t} else if (v !== parent[u]) {\n\t\t\tlow[u] = Math.min(low[u], discovered[v]);\n\t\t}\n\t});\n}\n\nexport default bridges;\n","// INVARIANT: only works for UNDIRECTED graph\n// calculates clustering coefficient for given node\nconst clusteringCoefficient = (g) => {\n\tconst res = [];\n\n\tg.adjList.forEach((neighbors, node) => {\n\t\tres.push({ node: node, cc: clusteringIndividual(g, node) });\n\t});\n\treturn res;\n};\n\nconst clusteringIndividual = (g, node) => {\n\tconst neighbors = g.adjList.get(node);\n\t// number of edges between neighbors\n\tconst numNeighbors = neighbors.length;\n\t// calculates total possible number of pairs, i.e. n choose 2\n\tconst numPairs = factorial(numNeighbors) / (factorial(numNeighbors - 2) * 2);\n\n\t// for each pair of nodes, check to see if there is edge between\n\tlet count = 0;\n\tneighbors.forEach(({ node: neighborId, weight }) => {\n\t\tneighbors.forEach(({ node: neighborId2, weight2 }) => {\n\t\t\tif (neighborId !== neighborId2) {\n\t\t\t\tconst nodes = g.adjList.get(neighborId);\n\t\t\t\tnodes.forEach(({ node: neighborId3, weight3 }) => {\n\t\t\t\t\tcount += neighborId3 === neighborId2 ? 1 : 0;\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t});\n\n\t// divide by 2 b/c undirected\n\tconst numEdges = count / 2.0;\n\treturn numEdges / numPairs;\n};\n\n// calculates factorial, used in calculation of all possible pairs\nfunction factorial(num) {\n\tif (num === 0 || num === 1) {\n\t\treturn 1;\n\t}\n\tfor (var i = num - 1; i > 0; i--) {\n\t\tnum *= i;\n\t}\n\treturn num;\n}\n\nexport default clusteringCoefficient;\n","// start - node to start DFS from\n// only visits nodes reachable from start (NOT full traversal)\nconst dfs = (g, start) => {\n\t// stack for iterative DFS\n\tconst stack = [];\n\t// array of nodes to return\n\tconst result = [];\n\t// set of discovered nodes\n\tconst discovered = new Set();\n\t// initialize by adding start node\n\tstack.push(start);\n\n\twhile (stack.length !== 0) {\n\t\t// pop stack, look at node's neighbors\n\t\tconst curr = stack.pop();\n\t\tconst outneighbors = g.adjList.get(curr);\n\n\t\t// if we haven't seen this node, add the node\n\t\tif (!discovered.has(curr)) {\n\t\t\tresult.push(curr);\n\t\t\tdiscovered.add(curr);\n\t\t}\n\n\t\t// add each neighbor of current node to stack\n\t\toutneighbors.forEach(({ node, weight }) => {\n\t\t\tif (!discovered.has(node)) {\n\t\t\t\tstack.push(node);\n\t\t\t}\n\t\t});\n\t}\n\n\treturn result;\n};\n\nexport default dfs;\n","// calculates shortest paths from start node to ALL other nodes via Dijkstra's algorithm\nconst dijkstra = (g, start) => {\n\t// map to store current distances from start node\n\tconst distances = new Map();\n\t// store each node with its minimum distance from the start\n\tconst res = [];\n\t// initialize distances to infinity for all nodes except start\n\tg.adjList.forEach((value, node) => distances.set(node, Number.MAX_VALUE));\n\tdistances.set(start, 0);\n\n\t// max is number of keys\n\tlet numIterations = 0;\n\tconst maxSize = g.adjList.size;\n\twhile (numIterations++ < maxSize) {\n\t\tlet minDist = Number.MAX_VALUE;\n\t\tlet minNode = -1;\n\t\tdistances.forEach((val, key) => {\n\t\t\t// update minimum distance and node\n\t\t\tif (val < minDist) {\n\t\t\t\tminNode = key;\n\t\t\t\tminDist = val;\n\t\t\t}\n\t\t});\n\t\tif (minNode >= 0) {\n\t\t\tres.push({ node: minNode, distance: minDist });\n\t\t\tdistances.delete(minNode);\n\t\t\t// update distance if less than running minimum distance\n\t\t\tg.adjList.get(minNode).forEach(({ node, weight }) => {\n\t\t\t\tdistances.set(node, Math.min(distances.get(node), minDist + weight));\n\t\t\t});\n\t\t}\n\t}\n\treturn res;\n};\n\nexport default dijkstra;\n","// Tarjan's algorithm (full recursive DFS traversal)\nconst topoSort = (g) => {\n\t// stack of nodes to return in order of decreasing finish timed\n\tconst finished = [];\n\t// map of node to color (0 is undiscovered, 1 is discovered, 2 is finished)\n\tconst color = new Map();\n\tlet valid = true;\n\n\t// initialize color of each node to 0 (undiscovered)\n\tg.adjList.forEach((values, node) => {\n\t\tcolor.set(node, 0);\n\t});\n\n\tg.adjList.forEach((values, node) => {\n\t\t// if undiscovered, visit node\n\t\tif (color.get(node) === 0) {\n\t\t\tif (!dfsVisit(g, node, color, finished)) {\n\t\t\t\tvalid = false;\n\t\t\t}\n\t\t}\n\t});\n\t// return nodes in decreasing order of finish times\n\treturn { valid: valid, res: finished.reverse() };\n};\n\n// DFS helper method\nfunction dfsVisit(g, node, color, finished) {\n\tcolor.set(node, 1);\n\t// iterate through neighbors\n\tconst neighbors = g.adjList.get(node);\n\tlet valid = true;\n\tneighbors.forEach(({ node: v, weight }) => {\n\t\t// found back edge, which implies cycle exists so no valid topo sort\n\t\tif (color.get(v) === 1) {\n\t\t\tvalid = false;\n\t\t}\n\n\t\t// if node undiscovered and no cycles have been found, visit node\n\t\tif (color.get(v) === 0) {\n\t\t\tif (!dfsVisit(g, v, color, finished)) {\n\t\t\t\tvalid = false;\n\t\t\t}\n\t\t}\n\t});\n\n\t// finish node\n\tcolor.set(node, 2);\n\t// push node to stack once finished\n\tfinished.push(node);\n\treturn valid;\n}\n\nexport default topoSort;\n","// INVARIANT: assumes undirected graph\n// returns a Set of obj {NodeA, NodeB}, which represents edges formed\n// Note: if edge forms between NodeA and NodeB, output set will contain\n// {NodeA, NodeB} and {NodeB, NodeA}\nconst triadicClosure = (g) => {\n\tconst res = new Set();\n\n\t/* \n    Iterate through neighbors of A and B.\n    If node A and node B share a neighbor, \n    by triadic closure, an edge between A \n    and B will likely form, so add it to set. \n   */\n\tg.adjList.forEach((neighborsA, nodeA) => {\n\t\tg.adjList.forEach((neighborsB, nodeB) => {\n\t\t\tif (\n\t\t\t\tnodeA !== nodeB &&\n\t\t\t\tshareNeighbor(neighborsA, neighborsB) &&\n\t\t\t\t!includesNode(\n\t\t\t\t\tneighborsA,\n\t\t\t\t\tnodeB\n\t\t\t\t) /* nodeA's neighbors does not include nodeB */\n\t\t\t) {\n\t\t\t\tres.add({ NodeA: nodeA, NodeB: nodeB });\n\t\t\t}\n\t\t});\n\t});\n\treturn res;\n};\n\n// check if list of neighbors includes node\nconst includesNode = (neighborsA, nodeB) => {\n\tvar included = false;\n\tneighborsA.forEach(({ node: nodeA, weight }) => {\n\t\tif (nodeA === nodeB) {\n\t\t\tincluded = true;\n\t\t}\n\t});\n\treturn included;\n};\n\n// check if two nodes have a common neighbor\nconst shareNeighbor = (neighborsA, neighborsB) => {\n\tvar shared = false;\n\tneighborsA.forEach((neighborA) => {\n\t\tif (neighborsB.some((neighborB) => neighborA.node === neighborB.node)) {\n\t\t\tshared = true;\n\t\t}\n\t});\n\treturn shared;\n};\n\nexport default triadicClosure;\n","import React, { Component } from \"react\";\nimport Draggable from \"react-draggable\"; // Both at the same time\nimport Xarrow from \"react-xarrows\";\nimport Results from \"./Results\";\n\nimport bfs from \"../algos/bfs\";\nimport bridges from \"../algos/bridges\";\nimport clusteringCoefficient from \"../algos/clusteringCoefficient\";\nimport dfs from \"../algos/dfs\";\nimport dijkstra from \"../algos/dijkstra\";\nimport topoSort from \"../algos/topoSort\";\nimport triadicClosure from \"../algos/triadicClosure\";\n\n// dimensions for nodes\nconst DIM = 62.5;\n\n// styles for drawing nodes\nconst circleStyle = (selected, x, y) => {\n  return {\n    padding: 0,\n    margin: 10,\n    position: \"absolute\",\n    backgroundColor: selected ? \"#ffd3b4\" : \"#98ddca\",\n    borderRadius: \"50%\",\n    border: \"2px solid black\",\n    width: DIM,\n    height: DIM,\n    lineHeight: `${DIM}px`,\n    left: `${x - DIM / 2}px`,\n    top: `${y - DIM / 2}px`,\n    outlineWidth: 0,\n  };\n};\n\n// toggles color of edges if selected\nconst edgeColor = (selected) => {\n  return selected ? \"#ffd3b4\" : \"#98ddca\";\n};\n\n// initial state for graph canvas\nconst initialState = (props) => {\n  return {\n    nextId: 0,\n    selectedId: -1,\n    selectedEdge: { a: -1, b: -1 },\n    undirected: props.selectedType === \"undirected\",\n    unweighted: props.selectedWeight === \"unweighted\",\n    algorithm: props.algorithm,\n    cleared: props.cleared,\n    results: props.result ? props.result : \"\",\n    open: false,\n\n    // classes: useStyles(),\n  };\n};\n\nclass Graph extends Component {\n  constructor(props) {\n    super(props);\n    // maps node to object with node as key and edge weight as value\n    this.adjList = new Map();\n    this.nodeToElement = new Map();\n    // set initial state\n    this.state = initialState(props);\n\n    this.getClickCoords = this.getClickCoords.bind(this);\n    this.addNode = this.addNode.bind(this);\n    this.selectNode = this.selectNode.bind(this);\n    this.addEdge = this.addEdge.bind(this);\n  }\n\n  // TODO (not as important since this doesn't affect performance too much - and not visible from normal usage): fix bug where this gets called multiple times\n  shouldComponentUpdate(nextProps) {\n    // condition to updated weight and directionality\n    let updated = false;\n    if (\n      (nextProps.selectedType === \"undirected\") !== this.state.undirected ||\n      (nextProps.selectedWeight === \"unweighted\") !== this.state.unweighted\n    ) {\n      if (\n        (nextProps.selectedType === \"undirected\") !== this.state.undirected &&\n        !this.state.undirected\n      ) {\n        this.adjList.forEach((neighbors, id) => {\n          neighbors.forEach(({ node, weight }) => {\n            this.addEdge(node, id, weight);\n          });\n        });\n      }\n      this.setState({\n        undirected: nextProps.selectedType === \"undirected\",\n        unweighted: nextProps.selectedWeight === \"unweighted\",\n      });\n      updated = true;\n    }\n\n    // condition to update clear\n    if (this.state.cleared !== nextProps.cleared) {\n      this.adjList = new Map();\n      this.nodeToElement = new Map();\n      this.setState(initialState(nextProps));\n      updated = true;\n    }\n\n    // condition to run algorithm\n    if (\n      this.state.algorithm !== nextProps.selectedAlgorithm ||\n      this.state.changed\n    ) {\n      let result;\n      switch (nextProps.selectedAlgorithm) {\n        case \"bfs\":\n          // run bfs\n          if (this.state.selectedId >= 0) {\n            result = bfs(this, this.state.selectedId);\n          }\n          break;\n        case \"dfs\":\n          // run dfs\n          if (this.state.selectedId >= 0) {\n            result = dfs(this, this.state.selectedId);\n          }\n          break;\n        case \"dijkstra\":\n          // run dijkstra\n          if (this.state.selectedId >= 0) {\n            result = dijkstra(this, this.state.selectedId);\n          }\n          break;\n        case \"topo sort\":\n          // run topo sort\n          result = topoSort(this);\n          break;\n        case \"clustering\":\n          // run clustering\n          // TODO: do we want to run CC on all nodes?\n          if (this.state.selectedId >= 0) {\n            result = clusteringCoefficient(this, this.state.selectedId);\n          }\n          break;\n        case \"bridges\":\n          // run bridges\n          result = bridges(this);\n          break;\n        case \"triadic\":\n          // run triadic\n          result = triadicClosure(this);\n          break;\n        default:\n          break;\n      }\n      // update state based on current algorithm and result\n      this.setState({\n        results: result,\n        algorithm: nextProps.selectedAlgorithm,\n        changed: false,\n      });\n      this.forceUpdate();\n      updated = true;\n    }\n    return updated;\n  }\n\n  // get mouse click coordinates\n  getClickCoords = (event) => {\n    // from: https://stackoverflow.com/a/29296049/14198287\n    var e = event.target;\n    var dim = e.getBoundingClientRect();\n    var x = event.clientX - dim.left;\n    var y = event.clientY - dim.top;\n    return [x, y];\n  };\n\n  // adds a node to the graph, if it doesn't already exist\n  // does nothing if node already in graph\n  addNode = (e, id) => {\n    if (!this.adjList.has(id)) {\n      this.adjList.set(id, []);\n\n      const [x, y] = this.getClickCoords(e);\n      this.nodeToElement.set(id, () => (\n        <Draggable\n          bounds=\"parent\"\n          key={id}\n          onDrag={(e, ui) => {\n            this.setState({ changed: true });\n            this.forceUpdate();\n          }}\n        >\n          <div\n            tabIndex=\"1\"\n            onKeyDown={(e) => {\n              if (e.key === \"Backspace\" || e.key === \"Delete\") {\n                this.removeNode(id);\n              }\n            }}\n            style={circleStyle(this.state.selectedId === id, x, y)}\n            onClick={(e) => {\n              if (e.shiftKey) {\n                this.addEdge(this.state.selectedId, id, 1);\n              } else {\n                this.selectNode(e, id);\n              }\n              this.forceUpdate();\n            }}\n            className={`Node${id}`}\n            id={`Node${id}`}\n          >\n            {id}\n          </div>\n        </Draggable>\n      ));\n\n      this.setState({ selectedId: id }, () => {\n        this.forceUpdate();\n      });\n    }\n    return this;\n  };\n\n  // remove node if it's in the graph\n  // no effect if node isn't in graph\n  removeNode = (id) => {\n    // remove from lists of neighbors\n    this.adjList.forEach((neighbors, node) => {\n      this.adjList.set(\n        node,\n        neighbors.filter((val) => val !== id)\n      );\n\n      // remove entry in adjacency list\n      this.adjList.delete(id);\n      this.nodeToElement.delete(id);\n    });\n    this.forceUpdate();\n    return this;\n  };\n\n  // props = {out: number, in: number, weight: number}\n  addEdge = (outNode, inNode, weight) => {\n    if (this.adjList.has(outNode) && this.adjList.has(inNode)) {\n      this.adjList.set(outNode, [\n        ...this.adjList.get(outNode).filter((obj) => obj.node !== inNode),\n        { node: inNode, weight: weight },\n      ]);\n      if (this.state.undirected) {\n        this.adjList.set(inNode, [\n          ...this.adjList.get(inNode).filter((obj) => obj.node !== outNode),\n          { node: outNode, weight: weight },\n        ]);\n      }\n      this.setState(\n        {\n          changed: true,\n          selectedId: inNode,\n        },\n        () => {\n          this.shouldComponentUpdate({\n            cleared: this.state.cleared,\n            selectedType: this.state.undirected ? \"undirected\" : \"directed\",\n            selectedWeight: this.state.unweighted ? \"unweighted\" : \"weighted\",\n            selectedAlgorithm: this.state.algorithm,\n          });\n        }\n      );\n    }\n    this.forceUpdate();\n    return this;\n  };\n\n  // props = {out: number, in: number}\n  removeEdge = (outNode, inNode) => {\n    if (this.adjList.has(outNode)) {\n      this.adjList.set(\n        outNode,\n        this.adjList.get(outNode).filter((obj) => obj.node !== inNode)\n      );\n      if (this.state.undirected) {\n        this.adjList.set(\n          inNode,\n          this.adjList.get(inNode).filter((obj) => obj.node !== outNode)\n        );\n      }\n    }\n    this.forceUpdate();\n    return this;\n  };\n\n  selectNode = (e, id) => {\n    this.setState(\n      {\n        selectedId: id,\n        selectedEdge: { a: -1, b: -1 },\n        changed: true,\n      },\n      () => {\n        this.shouldComponentUpdate({\n          cleared: this.state.cleared,\n          selectedType: this.state.undirected ? \"undirected\" : \"directed\",\n          selectedWeight: this.state.unweighted ? \"unweighted\" : \"weighted\",\n          selectedAlgorithm: this.state.algorithm,\n        });\n      }\n    );\n\n    this.forceUpdate();\n    e.stopPropagation();\n  };\n\n  render() {\n    const nodes = [];\n    const it = this.nodeToElement.values();\n    let res = it.next();\n    while (!res.done) {\n      nodes.push(res.value());\n      res = it.next();\n    }\n    const edges = [];\n    const drawnEdges = [];\n    this.adjList.forEach((neighbors, id) => {\n      neighbors.forEach((neighbor) => {\n        if (\n          !this.state.undirected ||\n          !drawnEdges.some(\n            ({ inNode, outNode }) => inNode === neighbor.node && outNode === id\n          )\n        ) {\n          drawnEdges.push({ inNode: id, outNode: neighbor.node });\n          edges.push(\n            <Xarrow\n              key={`Node${id}-Node${neighbor.node}`}\n              start={`Node${id}`}\n              end={`Node${neighbor.node}`}\n              label={!this.state.unweighted ? `${neighbor.weight}` : \"\"}\n              showHead={!this.state.undirected}\n              color={edgeColor(\n                this.state.selectedEdge.a === id &&\n                  this.state.selectedEdge.b === neighbor.node\n              )}\n              strokeWidth={5}\n              onClick={(e) => {\n                this.setState({\n                  selectedId: -1,\n                  selectedEdge: { a: id, b: neighbor.node },\n                });\n                e.stopPropagation();\n                this.forceUpdate();\n              }}\n              tabIndex=\"1\"\n              onKeyDown={(e) => {\n                if (e.key === \"Backspace\" || e.key === \"Delete\") {\n                  this.removeEdge(id, neighbor.node);\n                  this.setState({\n                    selectedEdge: { a: -1, b: -1 },\n                  });\n                } else if (e.key === \"Enter\") {\n                  this.removeEdge(id, neighbor.node);\n                  this.addEdge(id, neighbor.node, 0);\n                } else if (\n                  e.key === \"0\" ||\n                  e.key === \"1\" ||\n                  e.key === \"2\" ||\n                  e.key === \"3\" ||\n                  e.key === \"4\" ||\n                  e.key === \"5\" ||\n                  e.key === \"6\" ||\n                  e.key === \"7\" ||\n                  e.key === \"8\" ||\n                  e.key === \"9\"\n                ) {\n                  let edgeWeight = 1;\n                  this.adjList\n                    .get(id)\n                    .forEach(\n                      ({ node, weight }) =>\n                        (edgeWeight =\n                          node === neighbor.node ? weight : edgeWeight)\n                    );\n                  this.removeEdge(id, neighbor.node);\n                  this.addEdge(\n                    id,\n                    neighbor.node,\n                    edgeWeight * 10 + parseInt(e.key)\n                  );\n\n                  this.forceUpdate();\n                }\n                this.setState({ changed: true });\n              }}\n            />\n          );\n        }\n      });\n    });\n\n    const dottedEdges = [];\n    const drawnDottedEdges = [];\n    if (this.state.algorithm === \"triadic\") {\n      this.state.results.forEach(({ NodeA, NodeB }) => {\n        if (\n          !this.state.undirected ||\n          !drawnDottedEdges.some(\n            ({ inNode, outNode }) => inNode === NodeB && outNode === NodeA\n          )\n        ) {\n          drawnDottedEdges.push({ inNode: NodeA, outNode: NodeB });\n          dottedEdges.push(\n            <Xarrow\n              key={`Node${NodeA}-Node${NodeB}`}\n              start={`Node${NodeA}`}\n              end={`Node${NodeB}`}\n              label={\"\"}\n              showHead={!this.state.undirected}\n              color={\"#98ddca\"}\n              strokeWidth={5}\n              dashness={{ strokeLen: 10, nonStrokeLen: 10 }}\n            />\n          );\n        }\n      });\n    }\n\n    return (\n      <div\n        onClick={() => {\n          this.setState({\n            selectedId: -1,\n            selectedEdge: { a: -1, b: -1 },\n            //\n          });\n          this.forceUpdate();\n        }}\n        onDoubleClick={(e) => {\n          if (\n            this.state.selectedId < 0 &&\n            this.state.selectedEdge.a === -1 &&\n            this.state.selectedEdge.b === -1\n          ) {\n            this.addNode(e, this.state.nextId);\n            this.setState({\n              nextId: this.state.nextId + 1,\n              selectedEdge: { a: -1, b: -1 },\n            });\n            this.forceUpdate();\n          }\n        }}\n        className=\"canvas\"\n      >\n        <div className=\"graph\">\n          {dottedEdges}\n          {edges}\n          {nodes}\n        </div>\n        <Results result={this.state.results} algorithm={this.state.algorithm} />\n      </div>\n    );\n  }\n}\n\nexport default Graph;\n","import React, { useState } from \"react\";\nimport Button from \"@material-ui/core/Button\";\nimport Radio from \"@material-ui/core/Radio\";\nimport RadioGroup from \"@material-ui/core/RadioGroup\";\nimport FormControlLabel from \"@material-ui/core/FormControlLabel\";\nimport FormControl from \"@material-ui/core/FormControl\";\nimport Dialog from \"@material-ui/core/Dialog\";\nimport DialogActions from \"@material-ui/core/DialogActions\";\nimport DialogContent from \"@material-ui/core/DialogContent\";\nimport DialogContentText from \"@material-ui/core/DialogContentText\";\nimport DialogTitle from \"@material-ui/core/DialogTitle\";\n\n// bottom toolbar for running algorithms, clearing graph, and viewing instructions\nconst Toolbar = ({\n  selectedType,\n  setSelectedType,\n  selectedWeight,\n  setSelectedWeight,\n  setSelectedAlgorithm,\n  setCleared,\n  cleared,\n}) => {\n  const instructionsText = (\n    <>\n      Double click to add a node. Single click to select a node or edge.\n      <br />\n      After selecting a node, shift click on another node to add an edge.\n      <br />\n      <br />\n      The default edge weight is 1. To change an edge weight, first press{\" \"}\n      <code>enter</code> to set the edge weight to 0. Then, type in any number\n      to append the digits to the edge weight.\n      <br />\n      <br />\n      Also, note that for some algorithms (BFS, DFS, and Dijkstra), a node must\n      be selected in order to run the algorithm. Selecting various nodes will\n      \"live update\" the results pane.\n    </>\n  );\n\n  // state for dialog box for instructions\n  const [open, setOpen] = useState(false);\n\n  // open dialog\n  const handleClickOpen = () => {\n    setOpen(true);\n  };\n\n  // close dialog\n  const handleClose = () => {\n    setOpen(false);\n  };\n\n  // disable buttons based on current graph specifications\n  const isDisabled = (alg) => {\n    if (alg === \"bfs\" || alg === \"dfs\" || alg === \"dijkstra\") {\n      return false;\n    } else if (alg === \"clustering\" || alg === \"bridges\") {\n      return selectedType !== \"undirected\";\n    } else if (alg === \"topo sort\") {\n      // need to check for cycles??\n      return selectedType !== \"directed\";\n    } else {\n      return false;\n    }\n  };\n\n  // manage radio button state\n  const handleChange = (e, type) => {\n    switch (type) {\n      case \"direction\":\n        setSelectedType(e.target.value);\n        break;\n      case \"weight\":\n        setSelectedWeight(e.target.value);\n        break;\n      default:\n        console.log(\"Invalid type\");\n        break;\n    }\n  };\n\n  // render toolbar\n  return (\n    <div className=\"toolbar\">\n      <div className=\"button-group\">\n        <div className=\"btn\">\n          <Button variant=\"contained\" onClick={handleClickOpen}>\n            Instructions\n          </Button>\n          <Dialog\n            open={open}\n            onClose={handleClose}\n            aria-labelledby=\"alert-dialog-title\"\n            aria-describedby=\"alert-dialog-description\"\n          >\n            <DialogTitle id=\"alert-dialog-title\">{\"Instructions\"}</DialogTitle>\n            <DialogContent>\n              <DialogContentText id=\"alert-dialog-description\">\n                {instructionsText}\n              </DialogContentText>\n            </DialogContent>\n            <DialogActions>\n              <Button onClick={handleClose} color=\"primary\" autoFocus>\n                Cancel\n              </Button>\n            </DialogActions>\n          </Dialog>\n        </div>\n        <div className=\"btn\">\n          <Button\n            variant=\"outlined\"\n            onClick={() => setSelectedAlgorithm(\"bfs\")}\n            disabled={isDisabled(\"bfs\")}\n          >\n            BFS\n          </Button>\n        </div>\n        <div className=\"btn\">\n          <Button\n            variant=\"outlined\"\n            onClick={(e) => setSelectedAlgorithm(\"dfs\")}\n            disabled={isDisabled(\"dfs\")}\n          >\n            DFS\n          </Button>\n        </div>\n        <div className=\"btn\">\n          <Button\n            variant=\"outlined\"\n            onClick={(e) => setSelectedAlgorithm(\"dijkstra\")}\n            disabled={isDisabled(\"dijkstra\")}\n          >\n            Dijkstra\n          </Button>\n        </div>\n        <div className=\"btn\">\n          <Button\n            variant=\"outlined\"\n            onClick={(e) => setSelectedAlgorithm(\"topo sort\")}\n            disabled={isDisabled(\"topo sort\")}\n          >\n            Topo Sort\n          </Button>\n        </div>\n        <div className=\"btn\">\n          <Button\n            variant=\"outlined\"\n            onClick={(e) => setSelectedAlgorithm(\"clustering\")}\n            disabled={isDisabled(\"clustering\")}\n          >\n            Clustering Coefficient\n          </Button>\n        </div>\n        <div className=\"btn\">\n          <Button\n            variant=\"outlined\"\n            onClick={(e) => setSelectedAlgorithm(\"bridges\")}\n            disabled={isDisabled(\"bridges\")}\n          >\n            Bridges\n          </Button>\n        </div>\n        <div className=\"btn\">\n          <Button\n            variant=\"outlined\"\n            onClick={(e) => setSelectedAlgorithm(\"triadic\")}\n            disabled={isDisabled(\"triadic\")}\n          >\n            Triadic Closure\n          </Button>\n        </div>\n        <div className=\"btn\">\n          <Button\n            variant=\"contained\"\n            color=\"secondary\"\n            onClick={() => {\n              setCleared(!cleared);\n              setSelectedAlgorithm(\"\");\n            }}\n          >\n            CLEAR\n          </Button>\n        </div>\n      </div>\n      <FormControl component=\"fieldset\">\n        <RadioGroup\n          aria-label=\"graph-type\"\n          name=\"controlled-radio-buttons-group\"\n          value={selectedType}\n          onChange={(e) => handleChange(e, \"direction\")}\n        >\n          <FormControlLabel\n            value=\"undirected\"\n            control={<Radio color=\"primary\" />}\n            label=\"Undirected\"\n          />\n          <FormControlLabel\n            value=\"directed\"\n            control={<Radio color=\"primary\" />}\n            label=\"Directed\"\n          />\n        </RadioGroup>\n      </FormControl>\n\n      <FormControl component=\"fieldset\">\n        <RadioGroup\n          aria-label=\"edge-type\"\n          name=\"controlled-radio-buttons-group\"\n          value={selectedWeight}\n          onChange={(e) => handleChange(e, \"weight\")}\n        >\n          <FormControlLabel\n            value=\"unweighted\"\n            control={<Radio color=\"primary\" />}\n            label=\"Unweighted\"\n          />\n          <FormControlLabel\n            value=\"weighted\"\n            control={<Radio color=\"primary\" />}\n            label=\"Weighted\"\n          />\n        </RadioGroup>\n      </FormControl>\n    </div>\n  );\n};\n\nexport default Toolbar;\n","import React, { useState } from \"react\";\nimport \"./App.css\";\nimport Graph from \"./components/Graph\";\nimport Toolbar from \"./components/Toolbar\";\n\nfunction App() {\n\t// state for undirected vs directed graph\n\tconst [selectedType, setSelectedType] = useState(\"undirected\");\n\t// state for unweighted vs weighted graph\n\tconst [selectedWeight, setSelectedWeight] = useState(\"unweighted\");\n\t// state for selected algorithm\n\tconst [selectedAlgorithm, setSelectedAlgorithm] = useState(\"\");\n\t// state for whether or not graph is cleared\n\tconst [cleared, setCleared] = useState(false);\n\n\treturn (\n\t\t<div className=\"app\">\n\t\t\t<Graph\n\t\t\t\tselectedType={selectedType}\n\t\t\t\tselectedWeight={selectedWeight}\n\t\t\t\tselectedAlgorithm={selectedAlgorithm}\n\t\t\t\tcleared={cleared}\n\t\t\t/>\n\t\t\t<Toolbar\n\t\t\t\tselectedType={selectedType}\n\t\t\t\tsetSelectedType={setSelectedType}\n\t\t\t\tselectedWeight={selectedWeight}\n\t\t\t\tsetSelectedWeight={setSelectedWeight}\n\t\t\t\tsetSelectedAlgorithm={setSelectedAlgorithm}\n\t\t\t\tcleared={cleared}\n\t\t\t\tsetCleared={setCleared}\n\t\t\t/>\n\t\t</div>\n\t);\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}