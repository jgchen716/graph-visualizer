{"ast":null,"code":"// performs full BFS traversal from given start node\nconst bfs = (g, start) => {\n  const seen = new Set(); // queue for BFS\n\n  let queue = [start]; // list of lists to store each layer/frontier of BFS traversal\n\n  let res = []; // while queue is not empty, proceed\n\n  while (queue.length !== 0) {\n    // add current layer/frontier\n    res.push([...queue]);\n    let tempQueue = []; // mark all parents as seen / discovered\n\n    queue.forEach(parent => {\n      seen.add(parent);\n    }); // add next layer/frontier of nodes to queue if we haven't seen it already\n\n    queue.forEach(parent => {\n      g.adjList.get(parent).forEach(({\n        node,\n        weight\n      }) => {\n        if (!tempQueue.includes(node) && !seen.has(node)) {\n          tempQueue.push(node);\n        }\n      });\n    }); // update queue\n\n    queue = [...tempQueue];\n  }\n\n  return res;\n};\n\nexport default bfs;","map":{"version":3,"sources":["/Users/jgchen/Desktop/Dev/graph-visualizer/src/algos/bfs.js"],"names":["bfs","g","start","seen","Set","queue","res","length","push","tempQueue","forEach","parent","add","adjList","get","node","weight","includes","has"],"mappings":"AAAA;AACA,MAAMA,GAAG,GAAG,CAACC,CAAD,EAAIC,KAAJ,KAAc;AACzB,QAAMC,IAAI,GAAG,IAAIC,GAAJ,EAAb,CADyB,CAEzB;;AACA,MAAIC,KAAK,GAAG,CAACH,KAAD,CAAZ,CAHyB,CAIzB;;AACA,MAAII,GAAG,GAAG,EAAV,CALyB,CAMzB;;AACA,SAAOD,KAAK,CAACE,MAAN,KAAiB,CAAxB,EAA2B;AAC1B;AACAD,IAAAA,GAAG,CAACE,IAAJ,CAAS,CAAC,GAAGH,KAAJ,CAAT;AACA,QAAII,SAAS,GAAG,EAAhB,CAH0B,CAI1B;;AACAJ,IAAAA,KAAK,CAACK,OAAN,CAAeC,MAAD,IAAY;AACzBR,MAAAA,IAAI,CAACS,GAAL,CAASD,MAAT;AACA,KAFD,EAL0B,CAQ1B;;AACAN,IAAAA,KAAK,CAACK,OAAN,CAAeC,MAAD,IAAY;AACzBV,MAAAA,CAAC,CAACY,OAAF,CAAUC,GAAV,CAAcH,MAAd,EAAsBD,OAAtB,CAA8B,CAAC;AAAEK,QAAAA,IAAF;AAAQC,QAAAA;AAAR,OAAD,KAAsB;AACnD,YAAI,CAACP,SAAS,CAACQ,QAAV,CAAmBF,IAAnB,CAAD,IAA6B,CAACZ,IAAI,CAACe,GAAL,CAASH,IAAT,CAAlC,EAAkD;AACjDN,UAAAA,SAAS,CAACD,IAAV,CAAeO,IAAf;AACA;AACD,OAJD;AAKA,KAND,EAT0B,CAgB1B;;AACAV,IAAAA,KAAK,GAAG,CAAC,GAAGI,SAAJ,CAAR;AACA;;AACD,SAAOH,GAAP;AACA,CA3BD;;AA6BA,eAAeN,GAAf","sourcesContent":["// performs full BFS traversal from given start node\nconst bfs = (g, start) => {\n\tconst seen = new Set();\n\t// queue for BFS\n\tlet queue = [start];\n\t// list of lists to store each layer/frontier of BFS traversal\n\tlet res = [];\n\t// while queue is not empty, proceed\n\twhile (queue.length !== 0) {\n\t\t// add current layer/frontier\n\t\tres.push([...queue]);\n\t\tlet tempQueue = [];\n\t\t// mark all parents as seen / discovered\n\t\tqueue.forEach((parent) => {\n\t\t\tseen.add(parent);\n\t\t});\n\t\t// add next layer/frontier of nodes to queue if we haven't seen it already\n\t\tqueue.forEach((parent) => {\n\t\t\tg.adjList.get(parent).forEach(({ node, weight }) => {\n\t\t\t\tif (!tempQueue.includes(node) && !seen.has(node)) {\n\t\t\t\t\ttempQueue.push(node);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\t// update queue\n\t\tqueue = [...tempQueue];\n\t}\n\treturn res;\n};\n\nexport default bfs;\n"]},"metadata":{},"sourceType":"module"}