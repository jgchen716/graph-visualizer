{"ast":null,"code":"// calculates shortest paths from start node to ALL other nodes via Dijkstra's algorithm\nconst dijkstra = (g, start) => {\n  // map to store current distances from start node\n  const distances = new Map(); // store each node with its minimum distance from the start\n\n  const res = []; // initialize distances to infinity for all nodes except start\n\n  g.adjList.forEach((value, node) => distances.set(node, Number.MAX_VALUE));\n  distances.set(start, 0); // max is number of keys\n\n  let numIterations = 0;\n  const maxSize = g.adjList.size;\n\n  while (numIterations++ < maxSize) {\n    let minDist = Number.MAX_VALUE;\n    let minNode = -1;\n    distances.forEach((val, key) => {\n      // update minimum distance and node\n      if (val < minDist) {\n        minNode = key;\n        minDist = val;\n      }\n    });\n\n    if (minNode >= 0) {\n      res.push({\n        node: minNode,\n        distance: minDist\n      });\n      distances.delete(minNode); // update distance if less than running minimum distance\n\n      g.adjList.get(minNode).forEach(({\n        node,\n        weight\n      }) => {\n        distances.set(node, Math.min(distances.get(node), minDist + weight));\n      });\n    }\n  }\n\n  return res;\n};\n\nexport default dijkstra;","map":{"version":3,"sources":["/Users/jgchen/Desktop/Dev/graph-visualizer/src/algos/dijkstra.js"],"names":["dijkstra","g","start","distances","Map","res","adjList","forEach","value","node","set","Number","MAX_VALUE","numIterations","maxSize","size","minDist","minNode","val","key","push","distance","delete","get","weight","Math","min"],"mappings":"AAAA;AACA,MAAMA,QAAQ,GAAG,CAACC,CAAD,EAAIC,KAAJ,KAAc;AAC9B;AACA,QAAMC,SAAS,GAAG,IAAIC,GAAJ,EAAlB,CAF8B,CAG9B;;AACA,QAAMC,GAAG,GAAG,EAAZ,CAJ8B,CAK9B;;AACAJ,EAAAA,CAAC,CAACK,OAAF,CAAUC,OAAV,CAAkB,CAACC,KAAD,EAAQC,IAAR,KAAiBN,SAAS,CAACO,GAAV,CAAcD,IAAd,EAAoBE,MAAM,CAACC,SAA3B,CAAnC;AACAT,EAAAA,SAAS,CAACO,GAAV,CAAcR,KAAd,EAAqB,CAArB,EAP8B,CAS9B;;AACA,MAAIW,aAAa,GAAG,CAApB;AACA,QAAMC,OAAO,GAAGb,CAAC,CAACK,OAAF,CAAUS,IAA1B;;AACA,SAAOF,aAAa,KAAKC,OAAzB,EAAkC;AACjC,QAAIE,OAAO,GAAGL,MAAM,CAACC,SAArB;AACA,QAAIK,OAAO,GAAG,CAAC,CAAf;AACAd,IAAAA,SAAS,CAACI,OAAV,CAAkB,CAACW,GAAD,EAAMC,GAAN,KAAc;AAC/B;AACA,UAAID,GAAG,GAAGF,OAAV,EAAmB;AAClBC,QAAAA,OAAO,GAAGE,GAAV;AACAH,QAAAA,OAAO,GAAGE,GAAV;AACA;AACD,KAND;;AAOA,QAAID,OAAO,IAAI,CAAf,EAAkB;AACjBZ,MAAAA,GAAG,CAACe,IAAJ,CAAS;AAAEX,QAAAA,IAAI,EAAEQ,OAAR;AAAiBI,QAAAA,QAAQ,EAAEL;AAA3B,OAAT;AACAb,MAAAA,SAAS,CAACmB,MAAV,CAAiBL,OAAjB,EAFiB,CAGjB;;AACAhB,MAAAA,CAAC,CAACK,OAAF,CAAUiB,GAAV,CAAcN,OAAd,EAAuBV,OAAvB,CAA+B,CAAC;AAAEE,QAAAA,IAAF;AAAQe,QAAAA;AAAR,OAAD,KAAsB;AACpDrB,QAAAA,SAAS,CAACO,GAAV,CAAcD,IAAd,EAAoBgB,IAAI,CAACC,GAAL,CAASvB,SAAS,CAACoB,GAAV,CAAcd,IAAd,CAAT,EAA8BO,OAAO,GAAGQ,MAAxC,CAApB;AACA,OAFD;AAGA;AACD;;AACD,SAAOnB,GAAP;AACA,CAhCD;;AAkCA,eAAeL,QAAf","sourcesContent":["// calculates shortest paths from start node to ALL other nodes via Dijkstra's algorithm\nconst dijkstra = (g, start) => {\n\t// map to store current distances from start node\n\tconst distances = new Map();\n\t// store each node with its minimum distance from the start\n\tconst res = [];\n\t// initialize distances to infinity for all nodes except start\n\tg.adjList.forEach((value, node) => distances.set(node, Number.MAX_VALUE));\n\tdistances.set(start, 0);\n\n\t// max is number of keys\n\tlet numIterations = 0;\n\tconst maxSize = g.adjList.size;\n\twhile (numIterations++ < maxSize) {\n\t\tlet minDist = Number.MAX_VALUE;\n\t\tlet minNode = -1;\n\t\tdistances.forEach((val, key) => {\n\t\t\t// update minimum distance and node\n\t\t\tif (val < minDist) {\n\t\t\t\tminNode = key;\n\t\t\t\tminDist = val;\n\t\t\t}\n\t\t});\n\t\tif (minNode >= 0) {\n\t\t\tres.push({ node: minNode, distance: minDist });\n\t\t\tdistances.delete(minNode);\n\t\t\t// update distance if less than running minimum distance\n\t\t\tg.adjList.get(minNode).forEach(({ node, weight }) => {\n\t\t\t\tdistances.set(node, Math.min(distances.get(node), minDist + weight));\n\t\t\t});\n\t\t}\n\t}\n\treturn res;\n};\n\nexport default dijkstra;\n"]},"metadata":{},"sourceType":"module"}