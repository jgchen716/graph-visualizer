{"ast":null,"code":"// returns a Set of obj {NodeA, NodeB}, which represents edges formed\n// Note: if edge forms between NodeA and NodeB, output set will contain\n// {NodeA, NodeB} and {NodeB, NodeA}\nconst triadicClosure = g => {\n  const res = new Set();\n  /* \n    Iterate through neighbors of A and B.\n    If node A and node B share a neighbor, \n    by triadic closure, an edge between A \n    and B will likely form, so add it to set. \n   */\n\n  g.adjList.forEach((neighborsA, nodeA) => {\n    g.adjList.forEach((neighborsB, nodeB) => {\n      if (nodeA !== nodeB && shareNeighbor(neighborsA, neighborsB) && !includesNode(neighborsA, nodeB)\n      /* nodeA's neighbors does not include nodeB */\n      ) {\n          res.add({\n            NodeA: nodeA,\n            NodeB: nodeB\n          });\n        }\n    });\n  });\n  return res;\n}; // check if list of neighbors includes node\n\n\nconst includesNode = (neighborsA, nodeB) => {\n  var included = false;\n  neighborsA.forEach(({\n    node: nodeA,\n    weight\n  }) => {\n    if (nodeA === nodeB) {\n      included = true;\n    }\n  });\n  return included;\n}; // check if two nodes have a common neighbor\n\n\nconst shareNeighbor = (neighborsA, neighborsB) => {\n  var shared = false;\n  neighborsA.forEach(neighborA => {\n    if (neighborsB.some(neighborB => neighborA.node === neighborB.node)) {\n      shared = true;\n    }\n  });\n  return shared;\n};\n\nexport default triadicClosure;","map":{"version":3,"sources":["/Users/jgchen/Desktop/Dev/graph-visualizer/src/algos/triadicClosure.js"],"names":["triadicClosure","g","res","Set","adjList","forEach","neighborsA","nodeA","neighborsB","nodeB","shareNeighbor","includesNode","add","NodeA","NodeB","included","node","weight","shared","neighborA","some","neighborB"],"mappings":"AAAA;AACA;AACA;AACA,MAAMA,cAAc,GAAIC,CAAD,IAAO;AAC5B,QAAMC,GAAG,GAAG,IAAIC,GAAJ,EAAZ;AAEA;AACF;AACA;AACA;AACA;AACA;;AACEF,EAAAA,CAAC,CAACG,OAAF,CAAUC,OAAV,CAAkB,CAACC,UAAD,EAAaC,KAAb,KAAuB;AACvCN,IAAAA,CAAC,CAACG,OAAF,CAAUC,OAAV,CAAkB,CAACG,UAAD,EAAaC,KAAb,KAAuB;AACvC,UACEF,KAAK,KAAKE,KAAV,IACAC,aAAa,CAACJ,UAAD,EAAaE,UAAb,CADb,IAEA,CAACG,YAAY,CACXL,UADW,EAEXG,KAFW;AAGX;AANJ,QAOE;AACAP,UAAAA,GAAG,CAACU,GAAJ,CAAQ;AAAEC,YAAAA,KAAK,EAAEN,KAAT;AAAgBO,YAAAA,KAAK,EAAEL;AAAvB,WAAR;AACD;AACF,KAXD;AAYD,GAbD;AAcA,SAAOP,GAAP;AACD,CAxBD,C,CA0BA;;;AACA,MAAMS,YAAY,GAAG,CAACL,UAAD,EAAaG,KAAb,KAAuB;AAC1C,MAAIM,QAAQ,GAAG,KAAf;AACAT,EAAAA,UAAU,CAACD,OAAX,CAAmB,CAAC;AAAEW,IAAAA,IAAI,EAAET,KAAR;AAAeU,IAAAA;AAAf,GAAD,KAA6B;AAC9C,QAAIV,KAAK,KAAKE,KAAd,EAAqB;AACnBM,MAAAA,QAAQ,GAAG,IAAX;AACD;AACF,GAJD;AAKA,SAAOA,QAAP;AACD,CARD,C,CAUA;;;AACA,MAAML,aAAa,GAAG,CAACJ,UAAD,EAAaE,UAAb,KAA4B;AAChD,MAAIU,MAAM,GAAG,KAAb;AACAZ,EAAAA,UAAU,CAACD,OAAX,CAAoBc,SAAD,IAAe;AAChC,QAAIX,UAAU,CAACY,IAAX,CAAiBC,SAAD,IAAeF,SAAS,CAACH,IAAV,KAAmBK,SAAS,CAACL,IAA5D,CAAJ,EAAuE;AACrEE,MAAAA,MAAM,GAAG,IAAT;AACD;AACF,GAJD;AAKA,SAAOA,MAAP;AACD,CARD;;AAUA,eAAelB,cAAf","sourcesContent":["// returns a Set of obj {NodeA, NodeB}, which represents edges formed\n// Note: if edge forms between NodeA and NodeB, output set will contain\n// {NodeA, NodeB} and {NodeB, NodeA}\nconst triadicClosure = (g) => {\n  const res = new Set();\n\n  /* \n    Iterate through neighbors of A and B.\n    If node A and node B share a neighbor, \n    by triadic closure, an edge between A \n    and B will likely form, so add it to set. \n   */\n  g.adjList.forEach((neighborsA, nodeA) => {\n    g.adjList.forEach((neighborsB, nodeB) => {\n      if (\n        nodeA !== nodeB &&\n        shareNeighbor(neighborsA, neighborsB) &&\n        !includesNode(\n          neighborsA,\n          nodeB\n        ) /* nodeA's neighbors does not include nodeB */\n      ) {\n        res.add({ NodeA: nodeA, NodeB: nodeB });\n      }\n    });\n  });\n  return res;\n};\n\n// check if list of neighbors includes node\nconst includesNode = (neighborsA, nodeB) => {\n  var included = false;\n  neighborsA.forEach(({ node: nodeA, weight }) => {\n    if (nodeA === nodeB) {\n      included = true;\n    }\n  });\n  return included;\n};\n\n// check if two nodes have a common neighbor\nconst shareNeighbor = (neighborsA, neighborsB) => {\n  var shared = false;\n  neighborsA.forEach((neighborA) => {\n    if (neighborsB.some((neighborB) => neighborA.node === neighborB.node)) {\n      shared = true;\n    }\n  });\n  return shared;\n};\n\nexport default triadicClosure;\n"]},"metadata":{},"sourceType":"module"}