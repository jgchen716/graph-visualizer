{"ast":null,"code":"// calculates clustering coefficient for given node\nconst clusteringCoefficient = g => {\n  const res = [];\n  g.adjList.forEach((neighbors, node) => {\n    res.push({\n      node: node,\n      cc: clusteringIndividual(g, node)\n    });\n  });\n  return res;\n};\n\nconst clusteringIndividual = (g, node) => {\n  const neighbors = g.adjList.get(node); // number of edges between neighbors\n\n  const numNeighbors = neighbors.length; // calculates total possible number of pairs, i.e. n choose 2\n\n  const numPairs = factorial(numNeighbors) / (factorial(numNeighbors - 2) * 2); // for each pair of nodes, check to see if there is edge between\n\n  let count = 0;\n  neighbors.forEach(({\n    node: neighborId,\n    weight\n  }) => {\n    neighbors.forEach(({\n      node: neighborId2,\n      weight2\n    }) => {\n      if (neighborId !== neighborId2) {\n        const nodes = g.adjList.get(neighborId);\n        nodes.forEach(({\n          node: neighborId3,\n          weight3\n        }) => {\n          count += neighborId3 === neighborId2 ? 1 : 0;\n        });\n      }\n    });\n  }); // divide by 2 if undirected\n\n  const numEdges = count / (g.state.undirected ? 2.0 : 1.0);\n  const denom = g.state.undirected ? numPairs : numNeighbors * (numNeighbors - 1);\n  return denom !== 0 ? numEdges / denom : 0;\n}; // calculates factorial, used in calculation of all possible pairs\n\n\nfunction factorial(num) {\n  if (num === 0 || num === 1) {\n    return 1;\n  }\n\n  for (var i = num - 1; i > 0; i--) {\n    num *= i;\n  }\n\n  return num;\n}\n\nexport default clusteringCoefficient;","map":{"version":3,"sources":["/Users/jgchen/Desktop/Dev/graph-visualizer/src/algos/clusteringCoefficient.js"],"names":["clusteringCoefficient","g","res","adjList","forEach","neighbors","node","push","cc","clusteringIndividual","get","numNeighbors","length","numPairs","factorial","count","neighborId","weight","neighborId2","weight2","nodes","neighborId3","weight3","numEdges","state","undirected","denom","num","i"],"mappings":"AAAA;AACA,MAAMA,qBAAqB,GAAIC,CAAD,IAAO;AACnC,QAAMC,GAAG,GAAG,EAAZ;AAEAD,EAAAA,CAAC,CAACE,OAAF,CAAUC,OAAV,CAAkB,CAACC,SAAD,EAAYC,IAAZ,KAAqB;AACrCJ,IAAAA,GAAG,CAACK,IAAJ,CAAS;AAAED,MAAAA,IAAI,EAAEA,IAAR;AAAcE,MAAAA,EAAE,EAAEC,oBAAoB,CAACR,CAAD,EAAIK,IAAJ;AAAtC,KAAT;AACD,GAFD;AAGA,SAAOJ,GAAP;AACD,CAPD;;AASA,MAAMO,oBAAoB,GAAG,CAACR,CAAD,EAAIK,IAAJ,KAAa;AACxC,QAAMD,SAAS,GAAGJ,CAAC,CAACE,OAAF,CAAUO,GAAV,CAAcJ,IAAd,CAAlB,CADwC,CAExC;;AACA,QAAMK,YAAY,GAAGN,SAAS,CAACO,MAA/B,CAHwC,CAIxC;;AACA,QAAMC,QAAQ,GAAGC,SAAS,CAACH,YAAD,CAAT,IAA2BG,SAAS,CAACH,YAAY,GAAG,CAAhB,CAAT,GAA8B,CAAzD,CAAjB,CALwC,CAOxC;;AACA,MAAII,KAAK,GAAG,CAAZ;AACAV,EAAAA,SAAS,CAACD,OAAV,CAAkB,CAAC;AAAEE,IAAAA,IAAI,EAAEU,UAAR;AAAoBC,IAAAA;AAApB,GAAD,KAAkC;AAClDZ,IAAAA,SAAS,CAACD,OAAV,CAAkB,CAAC;AAAEE,MAAAA,IAAI,EAAEY,WAAR;AAAqBC,MAAAA;AAArB,KAAD,KAAoC;AACpD,UAAIH,UAAU,KAAKE,WAAnB,EAAgC;AAC9B,cAAME,KAAK,GAAGnB,CAAC,CAACE,OAAF,CAAUO,GAAV,CAAcM,UAAd,CAAd;AACAI,QAAAA,KAAK,CAAChB,OAAN,CAAc,CAAC;AAAEE,UAAAA,IAAI,EAAEe,WAAR;AAAqBC,UAAAA;AAArB,SAAD,KAAoC;AAChDP,UAAAA,KAAK,IAAIM,WAAW,KAAKH,WAAhB,GAA8B,CAA9B,GAAkC,CAA3C;AACD,SAFD;AAGD;AACF,KAPD;AAQD,GATD,EATwC,CAoBxC;;AACA,QAAMK,QAAQ,GAAGR,KAAK,IAAId,CAAC,CAACuB,KAAF,CAAQC,UAAR,GAAqB,GAArB,GAA2B,GAA/B,CAAtB;AACA,QAAMC,KAAK,GAAGzB,CAAC,CAACuB,KAAF,CAAQC,UAAR,GACVZ,QADU,GAEVF,YAAY,IAAIA,YAAY,GAAG,CAAnB,CAFhB;AAGA,SAAOe,KAAK,KAAK,CAAV,GAAcH,QAAQ,GAAGG,KAAzB,GAAiC,CAAxC;AACD,CA1BD,C,CA4BA;;;AACA,SAASZ,SAAT,CAAmBa,GAAnB,EAAwB;AACtB,MAAIA,GAAG,KAAK,CAAR,IAAaA,GAAG,KAAK,CAAzB,EAA4B;AAC1B,WAAO,CAAP;AACD;;AACD,OAAK,IAAIC,CAAC,GAAGD,GAAG,GAAG,CAAnB,EAAsBC,CAAC,GAAG,CAA1B,EAA6BA,CAAC,EAA9B,EAAkC;AAChCD,IAAAA,GAAG,IAAIC,CAAP;AACD;;AACD,SAAOD,GAAP;AACD;;AAED,eAAe3B,qBAAf","sourcesContent":["// calculates clustering coefficient for given node\nconst clusteringCoefficient = (g) => {\n  const res = [];\n\n  g.adjList.forEach((neighbors, node) => {\n    res.push({ node: node, cc: clusteringIndividual(g, node) });\n  });\n  return res;\n};\n\nconst clusteringIndividual = (g, node) => {\n  const neighbors = g.adjList.get(node);\n  // number of edges between neighbors\n  const numNeighbors = neighbors.length;\n  // calculates total possible number of pairs, i.e. n choose 2\n  const numPairs = factorial(numNeighbors) / (factorial(numNeighbors - 2) * 2);\n\n  // for each pair of nodes, check to see if there is edge between\n  let count = 0;\n  neighbors.forEach(({ node: neighborId, weight }) => {\n    neighbors.forEach(({ node: neighborId2, weight2 }) => {\n      if (neighborId !== neighborId2) {\n        const nodes = g.adjList.get(neighborId);\n        nodes.forEach(({ node: neighborId3, weight3 }) => {\n          count += neighborId3 === neighborId2 ? 1 : 0;\n        });\n      }\n    });\n  });\n\n  // divide by 2 if undirected\n  const numEdges = count / (g.state.undirected ? 2.0 : 1.0);\n  const denom = g.state.undirected\n    ? numPairs\n    : numNeighbors * (numNeighbors - 1);\n  return denom !== 0 ? numEdges / denom : 0;\n};\n\n// calculates factorial, used in calculation of all possible pairs\nfunction factorial(num) {\n  if (num === 0 || num === 1) {\n    return 1;\n  }\n  for (var i = num - 1; i > 0; i--) {\n    num *= i;\n  }\n  return num;\n}\n\nexport default clusteringCoefficient;\n"]},"metadata":{},"sourceType":"module"}