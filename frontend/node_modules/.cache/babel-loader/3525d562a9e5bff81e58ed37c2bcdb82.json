{"ast":null,"code":"/* Algorithm using modified DFS traversal to find all edges\nthat disconnect an UNDIRECTED graph (i.e. global bridges) */\n// Reference: https://www.geeksforgeeks.org/bridge-in-a-graph/\nconst bridges = g => {\n  let time = 0; // store edges that are bridges\n\n  let bridges = new Set(); // stores which nodes have been visited in DFS\n\n  let visited = new Set(); // maps nodes to parent nodes in DFS tree\n\n  let parent = {}; // map nodes to discovery time\n\n  let discovered = {}; // map indicating whether some node discovered earlier\n  // can be visited by subtree rooted at that node\n\n  let low = {};\n  g.adjList.forEach((values, node) => {\n    if (!visited.has(node)) {\n      dfsVisit(g, time, node, visited, discovered, low, parent, bridges);\n    }\n  });\n  return bridges;\n}; // DFS helper method\n\n\nfunction dfsVisit(g, time, u, visited, discovered, low, parent, bridges) {\n  time++;\n  visited.add(u);\n  discovered[u] = time;\n  low[u] = time; // iterate through neighbors\n\n  const neighbors = g.adjList.get(u);\n  neighbors.forEach(({\n    node: v,\n    weight\n  }) => {\n    if (!visited.has(v)) {\n      parent[v] = u;\n      dfsVisit(g, time, v, visited, discovered, low, parent, bridges);\n      low[u] = Math.min(low[u], low[v]);\n\n      if (low[v] > discovered[u]) {\n        bridges.add({\n          node1: u,\n          node2: v\n        });\n      }\n    } else if (v !== parent[u]) {\n      low[u] = Math.min(low[u], discovered[v]);\n    }\n  });\n}\n\nexport default bridges;","map":{"version":3,"sources":["/Users/jgchen/Desktop/Dev/graph-visualizer/src/algos/bridges.js"],"names":["bridges","g","time","Set","visited","parent","discovered","low","adjList","forEach","values","node","has","dfsVisit","u","add","neighbors","get","v","weight","Math","min","node1","node2"],"mappings":"AAAA;AACA;AACA;AACA,MAAMA,OAAO,GAAIC,CAAD,IAAO;AACtB,MAAIC,IAAI,GAAG,CAAX,CADsB,CAGtB;;AACA,MAAIF,OAAO,GAAG,IAAIG,GAAJ,EAAd,CAJsB,CAKtB;;AACA,MAAIC,OAAO,GAAG,IAAID,GAAJ,EAAd,CANsB,CAOtB;;AACA,MAAIE,MAAM,GAAG,EAAb,CARsB,CAStB;;AACA,MAAIC,UAAU,GAAG,EAAjB,CAVsB,CAWtB;AACA;;AACA,MAAIC,GAAG,GAAG,EAAV;AAEAN,EAAAA,CAAC,CAACO,OAAF,CAAUC,OAAV,CAAkB,CAACC,MAAD,EAASC,IAAT,KAAkB;AACnC,QAAI,CAACP,OAAO,CAACQ,GAAR,CAAYD,IAAZ,CAAL,EAAwB;AACvBE,MAAAA,QAAQ,CAACZ,CAAD,EAAIC,IAAJ,EAAUS,IAAV,EAAgBP,OAAhB,EAAyBE,UAAzB,EAAqCC,GAArC,EAA0CF,MAA1C,EAAkDL,OAAlD,CAAR;AACA;AACD,GAJD;AAMA,SAAOA,OAAP;AACA,CAtBD,C,CAwBA;;;AACA,SAASa,QAAT,CAAkBZ,CAAlB,EAAqBC,IAArB,EAA2BY,CAA3B,EAA8BV,OAA9B,EAAuCE,UAAvC,EAAmDC,GAAnD,EAAwDF,MAAxD,EAAgEL,OAAhE,EAAyE;AACxEE,EAAAA,IAAI;AACJE,EAAAA,OAAO,CAACW,GAAR,CAAYD,CAAZ;AACAR,EAAAA,UAAU,CAACQ,CAAD,CAAV,GAAgBZ,IAAhB;AACAK,EAAAA,GAAG,CAACO,CAAD,CAAH,GAASZ,IAAT,CAJwE,CAMxE;;AACA,QAAMc,SAAS,GAAGf,CAAC,CAACO,OAAF,CAAUS,GAAV,CAAcH,CAAd,CAAlB;AACAE,EAAAA,SAAS,CAACP,OAAV,CAAkB,CAAC;AAAEE,IAAAA,IAAI,EAAEO,CAAR;AAAWC,IAAAA;AAAX,GAAD,KAAyB;AAC1C,QAAI,CAACf,OAAO,CAACQ,GAAR,CAAYM,CAAZ,CAAL,EAAqB;AACpBb,MAAAA,MAAM,CAACa,CAAD,CAAN,GAAYJ,CAAZ;AACAD,MAAAA,QAAQ,CAACZ,CAAD,EAAIC,IAAJ,EAAUgB,CAAV,EAAad,OAAb,EAAsBE,UAAtB,EAAkCC,GAAlC,EAAuCF,MAAvC,EAA+CL,OAA/C,CAAR;AACAO,MAAAA,GAAG,CAACO,CAAD,CAAH,GAASM,IAAI,CAACC,GAAL,CAASd,GAAG,CAACO,CAAD,CAAZ,EAAiBP,GAAG,CAACW,CAAD,CAApB,CAAT;;AAEA,UAAIX,GAAG,CAACW,CAAD,CAAH,GAASZ,UAAU,CAACQ,CAAD,CAAvB,EAA4B;AAC3Bd,QAAAA,OAAO,CAACe,GAAR,CAAY;AAAEO,UAAAA,KAAK,EAAER,CAAT;AAAYS,UAAAA,KAAK,EAAEL;AAAnB,SAAZ;AACA;AACD,KARD,MAQO,IAAIA,CAAC,KAAKb,MAAM,CAACS,CAAD,CAAhB,EAAqB;AAC3BP,MAAAA,GAAG,CAACO,CAAD,CAAH,GAASM,IAAI,CAACC,GAAL,CAASd,GAAG,CAACO,CAAD,CAAZ,EAAiBR,UAAU,CAACY,CAAD,CAA3B,CAAT;AACA;AACD,GAZD;AAaA;;AAED,eAAelB,OAAf","sourcesContent":["/* Algorithm using modified DFS traversal to find all edges\nthat disconnect an UNDIRECTED graph (i.e. global bridges) */\n// Reference: https://www.geeksforgeeks.org/bridge-in-a-graph/\nconst bridges = (g) => {\n\tlet time = 0;\n\n\t// store edges that are bridges\n\tlet bridges = new Set();\n\t// stores which nodes have been visited in DFS\n\tlet visited = new Set();\n\t// maps nodes to parent nodes in DFS tree\n\tlet parent = {};\n\t// map nodes to discovery time\n\tlet discovered = {};\n\t// map indicating whether some node discovered earlier\n\t// can be visited by subtree rooted at that node\n\tlet low = {};\n\n\tg.adjList.forEach((values, node) => {\n\t\tif (!visited.has(node)) {\n\t\t\tdfsVisit(g, time, node, visited, discovered, low, parent, bridges);\n\t\t}\n\t});\n\n\treturn bridges;\n};\n\n// DFS helper method\nfunction dfsVisit(g, time, u, visited, discovered, low, parent, bridges) {\n\ttime++;\n\tvisited.add(u);\n\tdiscovered[u] = time;\n\tlow[u] = time;\n\n\t// iterate through neighbors\n\tconst neighbors = g.adjList.get(u);\n\tneighbors.forEach(({ node: v, weight }) => {\n\t\tif (!visited.has(v)) {\n\t\t\tparent[v] = u;\n\t\t\tdfsVisit(g, time, v, visited, discovered, low, parent, bridges);\n\t\t\tlow[u] = Math.min(low[u], low[v]);\n\n\t\t\tif (low[v] > discovered[u]) {\n\t\t\t\tbridges.add({ node1: u, node2: v });\n\t\t\t}\n\t\t} else if (v !== parent[u]) {\n\t\t\tlow[u] = Math.min(low[u], discovered[v]);\n\t\t}\n\t});\n}\n\nexport default bridges;\n"]},"metadata":{},"sourceType":"module"}