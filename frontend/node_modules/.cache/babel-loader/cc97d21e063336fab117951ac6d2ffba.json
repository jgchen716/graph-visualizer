{"ast":null,"code":"\"use strict\";\n/**\r\n * utility functions for preparing `startAnchor` and `endAnchor` to accept the diffrent types that can be passed.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getShortestLine = exports.prepareAnchorLines = void 0;\n\nconst index_1 = require(\"./index\");\n\nconst getAnchorsDefaultOffsets = (width, height) => {\n  return {\n    middle: {\n      rightness: width * 0.5,\n      bottomness: height * 0.5\n    },\n    left: {\n      rightness: 0,\n      bottomness: height * 0.5\n    },\n    right: {\n      rightness: width,\n      bottomness: height * 0.5\n    },\n    top: {\n      rightness: width * 0.5,\n      bottomness: 0\n    },\n    bottom: {\n      rightness: width * 0.5,\n      bottomness: height\n    }\n  };\n};\n\nexports.prepareAnchorLines = (anchor, anchorPos) => {\n  let defsOffsets = getAnchorsDefaultOffsets(anchorPos.right - anchorPos.x, anchorPos.bottom - anchorPos.y); // convert given anchors to array if not array already\n\n  let anchorChoice = Array.isArray(anchor) ? anchor : [anchor];\n  if (anchorChoice.length == 0) anchorChoice = [\"auto\"]; //now map each item in the array to relevant object\n\n  let anchorChoiceMapped = anchorChoice.map(anchorChoice => {\n    if (index_1.typeOf(anchorChoice) === \"string\") {\n      anchorChoice = anchorChoice;\n      return {\n        position: anchorChoice,\n        offset: {\n          rightness: 0,\n          bottomness: 0\n        }\n      };\n    } else if (index_1.typeOf(anchorChoice) === \"object\") {\n      if (!anchorChoice.offset) anchorChoice.offset = {\n        rightness: 0,\n        bottomness: 0\n      };\n      if (!anchorChoice.offset.bottomness) anchorChoice.offset.bottomness = 0;\n      if (!anchorChoice.offset.rightness) anchorChoice.offset.rightness = 0;\n      anchorChoice = anchorChoice;\n      return anchorChoice;\n    }\n  }); //now build the object that represents the users possibilities for different anchors\n\n  let anchorPossibilities = [];\n\n  if (anchorChoiceMapped.map(a => a.position).includes(\"auto\")) {\n    let autoAnchor = anchorChoiceMapped.find(a => a.position === \"auto\");\n    [\"left\", \"right\", \"top\", \"bottom\"].forEach(anchor => {\n      let offset = defsOffsets[anchor];\n      offset.rightness += autoAnchor.offset.rightness;\n      offset.bottomness += autoAnchor.offset.bottomness;\n      anchorPossibilities.push({\n        position: anchor,\n        offset\n      });\n    });\n  } else {\n    anchorChoiceMapped.forEach(customAnchor => {\n      let offset = defsOffsets[customAnchor.position];\n      offset.rightness += customAnchor.offset.rightness;\n      offset.bottomness += customAnchor.offset.bottomness;\n      anchorPossibilities.push({\n        position: customAnchor.position,\n        offset\n      });\n    });\n  } // now prepare this list of anchors to object expected by the `getShortestLine` function\n\n\n  return anchorPossibilities.map(pos => ({\n    x: anchorPos.x + pos.offset.rightness,\n    y: anchorPos.y + pos.offset.bottomness,\n    anchorPosition: pos.position\n  }));\n};\n\nconst dist = (p1, p2) => {\n  //length of line\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n};\n\nexports.getShortestLine = (sPoints, ePoints) => {\n  // closes tPair Of Points which feet to the specified anchors\n  let minDist = Infinity,\n      d = Infinity;\n  let closestPair;\n  sPoints.forEach(sp => {\n    ePoints.forEach(ep => {\n      d = dist(sp, ep);\n\n      if (d < minDist) {\n        minDist = d;\n        closestPair = {\n          startPointObj: sp,\n          endPointObj: ep\n        };\n      }\n    });\n  });\n  return closestPair;\n};","map":{"version":3,"sources":["../../src/utils/anchors.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/**\r\n * utility functions for preparing `startAnchor` and `endAnchor` to accept the diffrent types that can be passed.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getShortestLine = exports.prepareAnchorLines = void 0;\r\nconst index_1 = require(\"./index\");\r\nconst getAnchorsDefaultOffsets = (width, height) => {\r\n    return {\r\n        middle: { rightness: width * 0.5, bottomness: height * 0.5 },\r\n        left: { rightness: 0, bottomness: height * 0.5 },\r\n        right: { rightness: width, bottomness: height * 0.5 },\r\n        top: { rightness: width * 0.5, bottomness: 0 },\r\n        bottom: { rightness: width * 0.5, bottomness: height },\r\n    };\r\n};\r\nexports.prepareAnchorLines = (anchor, anchorPos) => {\r\n    let defsOffsets = getAnchorsDefaultOffsets(anchorPos.right - anchorPos.x, anchorPos.bottom - anchorPos.y);\r\n    // convert given anchors to array if not array already\r\n    let anchorChoice = Array.isArray(anchor) ? anchor : [anchor];\r\n    if (anchorChoice.length == 0)\r\n        anchorChoice = [\"auto\"];\r\n    //now map each item in the array to relevant object\r\n    let anchorChoiceMapped = anchorChoice.map((anchorChoice) => {\r\n        if (index_1.typeOf(anchorChoice) === \"string\") {\r\n            anchorChoice = anchorChoice;\r\n            return {\r\n                position: anchorChoice,\r\n                offset: { rightness: 0, bottomness: 0 },\r\n            };\r\n        }\r\n        else if (index_1.typeOf(anchorChoice) === \"object\") {\r\n            if (!anchorChoice.offset)\r\n                anchorChoice.offset = { rightness: 0, bottomness: 0 };\r\n            if (!anchorChoice.offset.bottomness)\r\n                anchorChoice.offset.bottomness = 0;\r\n            if (!anchorChoice.offset.rightness)\r\n                anchorChoice.offset.rightness = 0;\r\n            anchorChoice = anchorChoice;\r\n            return anchorChoice;\r\n        }\r\n    });\r\n    //now build the object that represents the users possibilities for different anchors\r\n    let anchorPossibilities = [];\r\n    if (anchorChoiceMapped.map((a) => a.position).includes(\"auto\")) {\r\n        let autoAnchor = anchorChoiceMapped.find((a) => a.position === \"auto\");\r\n        [\"left\", \"right\", \"top\", \"bottom\"].forEach((anchor) => {\r\n            let offset = defsOffsets[anchor];\r\n            offset.rightness += autoAnchor.offset.rightness;\r\n            offset.bottomness += autoAnchor.offset.bottomness;\r\n            anchorPossibilities.push({ position: anchor, offset });\r\n        });\r\n    }\r\n    else {\r\n        anchorChoiceMapped.forEach((customAnchor) => {\r\n            let offset = defsOffsets[customAnchor.position];\r\n            offset.rightness += customAnchor.offset.rightness;\r\n            offset.bottomness += customAnchor.offset.bottomness;\r\n            anchorPossibilities.push({ position: customAnchor.position, offset });\r\n        });\r\n    }\r\n    // now prepare this list of anchors to object expected by the `getShortestLine` function\r\n    return anchorPossibilities.map((pos) => ({\r\n        x: anchorPos.x + pos.offset.rightness,\r\n        y: anchorPos.y + pos.offset.bottomness,\r\n        anchorPosition: pos.position,\r\n    }));\r\n};\r\nconst dist = (p1, p2) => {\r\n    //length of line\r\n    return Math.sqrt(Math.pow((p1.x - p2.x), 2) + Math.pow((p1.y - p2.y), 2));\r\n};\r\nexports.getShortestLine = (sPoints, ePoints) => {\r\n    // closes tPair Of Points which feet to the specified anchors\r\n    let minDist = Infinity, d = Infinity;\r\n    let closestPair;\r\n    sPoints.forEach((sp) => {\r\n        ePoints.forEach((ep) => {\r\n            d = dist(sp, ep);\r\n            if (d < minDist) {\r\n                minDist = d;\r\n                closestPair = { startPointObj: sp, endPointObj: ep };\r\n            }\r\n        });\r\n    });\r\n    return closestPair;\r\n};\r\n//# sourceMappingURL=anchors.js.map"]},"metadata":{},"sourceType":"script"}