{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst react_1 = __importStar(require(\"react\"));\n\nconst lodash_isequal_1 = __importDefault(require(\"lodash.isequal\"));\n\nconst lodash_pick_1 = __importDefault(require(\"lodash.pick\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst prop_types_1 = __importDefault(require(\"prop-types\"));\n\nconst buzzier_1 = require(\"./utils/buzzier\");\n\nconst anchors_1 = require(\"./utils/anchors\");\n\nconst Xarrow = props => {\n  let {\n    startAnchor,\n    endAnchor,\n    label,\n    color,\n    lineColor,\n    headColor,\n    strokeWidth,\n    showHead,\n    headSize,\n    showTail,\n    tailColor,\n    tailSize,\n    path,\n    curveness,\n    dashness,\n    passProps,\n    SVGcanvasProps,\n    arrowBodyProps,\n    arrowHeadProps,\n    arrowTailProps,\n    divContainerProps,\n    SVGcanvasStyle,\n    divContainerStyle,\n    _extendSVGcanvas,\n    _debug,\n    _cpx1Offset,\n    _cpy1Offset,\n    _cpx2Offset,\n    _cpy2Offset\n  } = props,\n      extraProps = __rest(props, [\"startAnchor\", \"endAnchor\", \"label\", \"color\", \"lineColor\", \"headColor\", \"strokeWidth\", \"showHead\", \"headSize\", \"showTail\", \"tailColor\", \"tailSize\", \"path\", \"curveness\", \"dashness\", \"passProps\", \"SVGcanvasProps\", \"arrowBodyProps\", \"arrowHeadProps\", \"arrowTailProps\", \"divContainerProps\", \"SVGcanvasStyle\", \"divContainerStyle\", \"_extendSVGcanvas\", \"_debug\", \"_cpx1Offset\", \"_cpy1Offset\", \"_cpx2Offset\", \"_cpy2Offset\"]);\n\n  const selfRef = react_1.useRef(null);\n  const [anchorsRefs, setAnchorsRefs] = react_1.useState({\n    start: null,\n    end: null\n  });\n  const [prevPosState, setPrevPosState] = react_1.useState(null);\n  const [prevProps, setPrevProps] = react_1.useState(null);\n  /**\r\n   * determine if an update is needed and update if so.\r\n   * update is needed if one of the connected elements position was changed since last render, or if the ref to one\r\n   * of the elements has changed(it points to a different element).\r\n   */\n\n  const updateIfNeeded = () => {\n    // check if anchors refs changed\n    const start = utils_1.getElementByPropGiven(props.start);\n    const end = utils_1.getElementByPropGiven(props.end); // in case one of the elements does not mounted skip any update\n\n    if (start == null || end == null) return; // if anchors changed re-set them\n\n    if (!lodash_isequal_1.default(anchorsRefs, {\n      start,\n      end\n    })) {\n      initAnchorsRefs();\n    } else if (!lodash_isequal_1.default(props, prevProps)) {\n      //first check if any properties changed\n      if (prevProps) {\n        initProps();\n        let posState = getAnchorsPos();\n        setPrevPosState(posState);\n        updatePosition(posState);\n      }\n    } else {\n      //if the properties did not changed - update position if needed\n      let posState = getAnchorsPos();\n\n      if (!lodash_isequal_1.default(prevPosState, posState)) {\n        setPrevPosState(posState);\n        updatePosition(posState);\n      }\n    }\n  };\n\n  const initAnchorsRefs = () => {\n    const start = utils_1.getElementByPropGiven(props.start);\n    const end = utils_1.getElementByPropGiven(props.end);\n    setAnchorsRefs({\n      start,\n      end\n    });\n  };\n\n  const initProps = () => {\n    setPrevProps(props);\n  };\n\n  const monitorDOMchanges = () => {\n    window.addEventListener(\"resize\", updateIfNeeded);\n  };\n\n  const cleanMonitorDOMchanges = () => {\n    window.removeEventListener(\"resize\", updateIfNeeded);\n  };\n\n  react_1.useEffect(() => {\n    // console.log(\"xarrow mounted\");\n    initProps();\n    initAnchorsRefs();\n    monitorDOMchanges();\n    return () => {\n      cleanMonitorDOMchanges();\n    };\n  }, []);\n  react_1.useLayoutEffect(() => {\n    // console.log(\"xarrow rendered!\");\n    updateIfNeeded();\n  });\n  const [st, setSt] = react_1.useState({\n    //initial state\n    cx0: 0,\n    cy0: 0,\n    cw: 0,\n    ch: 0,\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0,\n    dx: 0,\n    dy: 0,\n    absDx: 0,\n    absDy: 0,\n    cpx1: 0,\n    cpy1: 0,\n    cpx2: 0,\n    cpy2: 0,\n    headOrient: 0,\n    tailOrient: 0,\n    labelStartPos: {\n      x: 0,\n      y: 0\n    },\n    labelMiddlePos: {\n      x: 0,\n      y: 0\n    },\n    labelEndPos: {\n      x: 0,\n      y: 0\n    },\n    arrowEnd: {\n      x: 0,\n      y: 0\n    },\n    arrowHeadOffset: {\n      x: 0,\n      y: 0\n    },\n    arrowTailOffset: {\n      x: 0,\n      y: 0\n    },\n    headOffset: 0,\n    excRight: 0,\n    excLeft: 0,\n    excUp: 0,\n    excDown: 0\n  });\n  headSize = Number(headSize);\n  strokeWidth = Number(strokeWidth);\n  headColor = headColor ? headColor : color;\n  tailColor = tailColor ? tailColor : color;\n  lineColor = lineColor ? lineColor : color;\n  let dashStroke = 0,\n      dashNone = 0,\n      animationSpeed,\n      animationDirection = 1;\n\n  if (dashness) {\n    if (typeof dashness === \"object\") {\n      dashStroke = dashness.strokeLen ? Number(dashness.strokeLen) : Number(strokeWidth) * 2;\n      dashNone = dashness.strokeLen ? Number(dashness.nonStrokeLen) : Number(strokeWidth);\n      animationSpeed = dashness.animation ? Number(dashness.animation) : null;\n    } else if (typeof dashness === \"boolean\") {\n      dashStroke = Number(strokeWidth) * 2;\n      dashNone = Number(strokeWidth);\n      animationSpeed = null;\n    }\n  }\n\n  let dashoffset = dashStroke + dashNone;\n\n  if (animationSpeed < 0) {\n    animationSpeed *= -1;\n    animationDirection = -1;\n  }\n\n  let labelStart = null,\n      labelMiddle = null,\n      labelEnd = null;\n\n  if (label) {\n    if (typeof label === \"string\" || \"type\" in label) labelMiddle = label;else if ([\"start\", \"middle\", \"end\"].some(key => key in label)) {\n      label = label;\n      ({\n        start: labelStart,\n        middle: labelMiddle,\n        end: labelEnd\n      } = label);\n    }\n  }\n\n  const getSelfPos = () => {\n    let {\n      left: xarrowElemX,\n      top: xarrowElemY\n    } = selfRef.current.getBoundingClientRect();\n    let xarrowStyle = getComputedStyle(selfRef.current);\n    let xarrowStyleLeft = Number(xarrowStyle.left.slice(0, -2));\n    let xarrowStyleTop = Number(xarrowStyle.top.slice(0, -2));\n    return {\n      x: xarrowElemX - xarrowStyleLeft,\n      y: xarrowElemY - xarrowStyleTop\n    };\n  };\n\n  const getAnchorsPos = () => {\n    let s = anchorsRefs.start.getBoundingClientRect();\n    let e = anchorsRefs.end.getBoundingClientRect();\n    return {\n      start: {\n        x: s.left,\n        y: s.top,\n        right: s.right,\n        bottom: s.bottom\n      },\n      end: {\n        x: e.left,\n        y: e.top,\n        right: e.right,\n        bottom: e.bottom\n      }\n    };\n  };\n  /**\r\n   * The Main logic of path calculation for the arrow.\r\n   * calculate new path and adjust canvas based on given properties.\r\n   * */\n\n\n  const updatePosition = positions => {\n    let {\n      start: sPos\n    } = positions;\n    let {\n      end: ePos\n    } = positions;\n    let headOrient = 0;\n    let tailOrient = 0; // convert startAnchor and endAnchor to list of objects represents allowed anchors.\n\n    let startPointsObj = anchors_1.prepareAnchorLines(startAnchor, sPos);\n    let endPointsObj = anchors_1.prepareAnchorLines(endAnchor, ePos); // choose the smallest path for 2 points from these possibilities.\n\n    let {\n      startPointObj,\n      endPointObj\n    } = anchors_1.getShortestLine(startPointsObj, endPointsObj);\n    let startAnchorPosition = startPointObj.anchorPosition,\n        endAnchorPosition = endPointObj.anchorPosition;\n    let startPoint = lodash_pick_1.default(startPointObj, [\"x\", \"y\"]),\n        endPoint = lodash_pick_1.default(endPointObj, [\"x\", \"y\"]);\n    let xarrowElemPos = getSelfPos();\n    let cx0 = Math.min(startPoint.x, endPoint.x) - xarrowElemPos.x;\n    let cy0 = Math.min(startPoint.y, endPoint.y) - xarrowElemPos.y;\n    let dx = endPoint.x - startPoint.x;\n    let dy = endPoint.y - startPoint.y;\n    let absDx = Math.abs(endPoint.x - startPoint.x);\n    let absDy = Math.abs(endPoint.y - startPoint.y);\n    let xSign = dx > 0 ? 1 : -1;\n    let ySign = dy > 0 ? 1 : -1;\n    let headOffset = headSize * 3 / 4 * strokeWidth;\n    let tailOffset = tailSize * 3 / 4 * strokeWidth;\n    let cu = Number(curveness);\n\n    if (path === \"straight\") {\n      cu = 0;\n      path = \"smooth\";\n    }\n\n    let biggerSide = headSize > tailSize ? headSize : tailSize;\n    let calc = strokeWidth + strokeWidth * biggerSide / 2;\n    let excRight = calc;\n    let excLeft = calc;\n    let excUp = calc;\n    let excDown = calc;\n    excLeft += Number(_extendSVGcanvas);\n    excRight += Number(_extendSVGcanvas);\n    excUp += Number(_extendSVGcanvas);\n    excDown += Number(_extendSVGcanvas); ////////////////////////////////////\n    // arrow point to point calculations\n\n    let x1 = 0,\n        x2 = absDx,\n        y1 = 0,\n        y2 = absDy;\n    if (dx < 0) [x1, x2] = [x2, x1];\n    if (dy < 0) [y1, y2] = [y2, y1]; ////////////////////////////////////\n    // arrow curviness and arrowhead placement calculations\n\n    let xHeadOffset = 0;\n    let yHeadOffset = 0;\n    let xTailOffset = 0;\n    let yTailOffset = 0;\n\n    if (cu === 0) {\n      // in case of straight path\n      let headAngel = Math.atan(absDy / absDx);\n\n      if (showHead) {\n        x2 -= headOffset * xSign * Math.cos(headAngel);\n        y2 -= headOffset * ySign * Math.sin(headAngel); // cpx2 -= headOffset * xSign * Math.cos(headAngel);\n        // cpy2 -= headOffset * ySign * Math.sin(headAngel);\n\n        headAngel *= ySign;\n        if (xSign < 0) headAngel = (Math.PI - headAngel * xSign) * xSign;\n        xHeadOffset = Math.cos(headAngel) * headOffset / 3 - Math.sin(headAngel) * (headSize * strokeWidth) / 2;\n        yHeadOffset = Math.cos(headAngel) * (headSize * strokeWidth) / 2 + Math.sin(headAngel) * headOffset / 3;\n        headOrient = headAngel * 180 / Math.PI;\n      }\n\n      let tailAngel = Math.atan(absDy / absDx);\n\n      if (showTail) {\n        x1 += tailOffset * xSign * Math.cos(tailAngel);\n        y1 += tailOffset * ySign * Math.sin(tailAngel); // cpx2 -= headOffset * xSign * Math.cos(headAngel);\n        // cpy2 -= headOffset * ySign * Math.sin(headAngel);\n\n        tailAngel *= -ySign;\n        if (xSign > 0) tailAngel = (Math.PI - tailAngel * xSign) * xSign;\n        xTailOffset = Math.cos(tailAngel) * tailOffset / 3 - Math.sin(tailAngel) * (tailSize * strokeWidth) / 2;\n        yTailOffset = Math.cos(tailAngel) * (tailSize * strokeWidth) / 2 + Math.sin(tailAngel) * tailOffset / 3;\n        tailOrient = tailAngel * 180 / Math.PI;\n      } //todo: add tail support\n\n    } else {\n      // in case of smooth path\n      if (endAnchorPosition === \"middle\") {\n        // in case a middle anchor is chosen for endAnchor choose from which side to attach to the middle of the element\n        if (absDx > absDy) {\n          endAnchorPosition = xSign ? \"left\" : \"right\";\n        } else {\n          endAnchorPosition = ySign ? \"top\" : \"bottom\";\n        }\n      }\n\n      if (showHead) {\n        if ([\"left\", \"right\"].includes(endAnchorPosition)) {\n          x2 -= headOffset * xSign; // cpx2 -= headOffset * xSign * 2;\n          // cpx1 += headOffset * xSign;\n\n          xHeadOffset = headOffset * xSign / 3;\n          yHeadOffset = headSize * strokeWidth * xSign / 2;\n\n          if (endAnchorPosition === \"left\") {\n            headOrient = 0;\n            if (xSign < 0) headOrient += 180;\n          } else {\n            headOrient = 180;\n            if (xSign > 0) headOrient += 180;\n          }\n        } else if ([\"top\", \"bottom\"].includes(endAnchorPosition)) {\n          yHeadOffset = headOffset * ySign / 3;\n          xHeadOffset = headSize * strokeWidth * -ySign / 2;\n          y2 -= headOffset * ySign; // cpy1 += headOffset * ySign;\n          // cpy2 -= headOffset * ySign;\n\n          if (endAnchorPosition === \"top\") {\n            headOrient = 270;\n            if (ySign > 0) headOrient += 180;\n          } else {\n            headOrient = 90;\n            if (ySign < 0) headOrient += 180;\n          }\n        }\n      }\n    }\n\n    if (showTail && cu !== 0) {\n      if ([\"left\", \"right\"].includes(startAnchorPosition)) {\n        x1 += tailOffset * xSign;\n        xTailOffset = -(tailOffset * xSign) / 3;\n        yTailOffset = -(tailSize * strokeWidth * xSign) / 2;\n\n        if (startAnchorPosition === \"left\") {\n          tailOrient = 180;\n          if (xSign < 0) tailOrient += 180;\n        } else {\n          tailOrient = 0;\n          if (xSign > 0) tailOrient += 180;\n        }\n      } else if ([\"top\", \"bottom\"].includes(startAnchorPosition)) {\n        yTailOffset = -(tailOffset * ySign) / 3;\n        xTailOffset = -(tailSize * strokeWidth * -ySign) / 2;\n        y1 += tailOffset * ySign; // cpy1 += tailOffset * ySign;\n        // cpy2 -= tailOffset * ySign;\n\n        if (startAnchorPosition === \"top\") {\n          tailOrient = 90;\n          if (ySign > 0) tailOrient += 180;\n        } else {\n          tailOrient = 270;\n          if (ySign < 0) tailOrient += 180;\n        }\n      }\n    } // if (endAnchorPosition == startAnchorPosition) headOrient += 180;\n\n\n    let arrowHeadOffset = {\n      x: xHeadOffset,\n      y: yHeadOffset\n    };\n    let arrowTailOffset = {\n      x: xTailOffset,\n      y: yTailOffset\n    };\n    let cpx1 = x1,\n        cpy1 = y1,\n        cpx2 = x2,\n        cpy2 = y2;\n    let curvesPossibilities = {};\n    if (path === \"smooth\") curvesPossibilities = {\n      hh: () => {\n        //horizontal - from right to left or the opposite\n        cpx1 += absDx * cu * xSign;\n        cpx2 -= absDx * cu * xSign; // if (absDx < 2 * headOffset) {\n        //   cpx1 += headOffset * xSign - absDx / 2;\n        //   cpx2 -= headOffset * xSign * 2 - absDx;\n        // }\n        // cpx1 += headOffset * 2 * xSign;\n        // cpx2 -= headOffset * 2 * xSign;\n      },\n      vv: () => {\n        //vertical - from top to bottom or opposite\n        cpy1 += absDy * cu * ySign;\n        cpy2 -= absDy * cu * ySign; // cpy1 += headOffset * 2 * ySign;\n        // cpy2 -= headOffset * 2 * ySign;\n      },\n      hv: () => {\n        // start horizontally then vertically\n        // from v side to h side\n        cpx1 += absDx * cu * xSign;\n        cpy2 -= absDy * cu * ySign;\n      },\n      vh: () => {\n        // start vertically then horizontally\n        // from h side to v side\n        cpy1 += absDy * cu * ySign;\n        cpx2 -= absDx * cu * xSign;\n      }\n    };else if (path === \"grid\") {\n      curvesPossibilities = {\n        hh: () => {\n          // cpx1 += (absDx * 0.5 - headOffset / 2) * xSign;\n          // cpx2 -= (absDx * 0.5 - headOffset / 2) * xSign;\n          cpx1 += absDx * 0.5 * xSign;\n          cpx2 -= absDx * 0.5 * xSign;\n\n          if (showHead) {\n            cpx1 -= headOffset / 2 * xSign;\n            cpx2 += headOffset / 2 * xSign;\n          }\n\n          if (showTail) {\n            cpx1 -= tailOffset / 2 * xSign;\n            cpx2 += tailOffset / 2 * xSign;\n          }\n        },\n        vv: () => {\n          // cpy1 += (absDy * 0.5 - headOffset / 2) * ySign;\n          // cpy2 -= (absDy * 0.5 - headOffset / 2) * ySign;\n          cpy1 += absDy * 0.5 * ySign;\n          cpy2 -= absDy * 0.5 * ySign;\n\n          if (showHead) {\n            cpy1 -= headOffset / 2 * ySign;\n            cpy2 += headOffset / 2 * ySign;\n          }\n\n          if (showTail) {\n            cpy1 -= tailOffset / 2 * ySign;\n            cpy2 += tailOffset / 2 * ySign;\n          }\n        },\n        hv: () => {\n          cpx1 = x2;\n        },\n        vh: () => {\n          cpy1 = y2;\n        }\n      };\n    } // smart select best curve for the current anchors\n\n    let selectedCurviness = \"\";\n    if ([\"left\", \"right\"].includes(startAnchorPosition)) selectedCurviness += \"h\";else if ([\"bottom\", \"top\"].includes(startAnchorPosition)) selectedCurviness += \"v\";else if (startAnchorPosition === \"middle\") selectedCurviness += \"m\";\n    if ([\"left\", \"right\"].includes(endAnchorPosition)) selectedCurviness += \"h\";else if ([\"bottom\", \"top\"].includes(endAnchorPosition)) selectedCurviness += \"v\";else if (endAnchorPosition === \"middle\") selectedCurviness += \"m\";\n    if (absDx > absDy) selectedCurviness = selectedCurviness.replace(/m/g, \"h\");else selectedCurviness = selectedCurviness.replace(/m/g, \"v\");\n    curvesPossibilities[selectedCurviness]();\n    cpx1 += _cpx1Offset;\n    cpy1 += _cpy1Offset;\n    cpx2 += _cpx2Offset;\n    cpy2 += _cpy2Offset; ////////////////////////////////////\n    // canvas smart size adjustments\n\n    const [xSol1, xSol2] = buzzier_1.buzzierMinSols(x1, cpx1, cpx2, x2);\n    const [ySol1, ySol2] = buzzier_1.buzzierMinSols(y1, cpy1, cpy2, y2);\n    if (xSol1 < 0) excLeft += -xSol1;\n    if (xSol2 > absDx) excRight += xSol2 - absDx;\n    if (ySol1 < 0) excUp += -ySol1;\n    if (ySol2 > absDy) excDown += ySol2 - absDy;\n\n    if (path === \"grid\") {\n      excLeft += calc;\n      excRight += calc;\n      excUp += calc;\n      excDown += calc;\n    }\n\n    x1 += excLeft;\n    x2 += excLeft;\n    y1 += excUp;\n    y2 += excUp;\n    cpx1 += excLeft;\n    cpx2 += excLeft;\n    cpy1 += excUp;\n    cpy2 += excUp;\n    const cw = absDx + excLeft + excRight,\n          ch = absDy + excUp + excDown;\n    cx0 -= excLeft;\n    cy0 -= excUp; //labels\n\n    const bzx = buzzier_1.bzFunction(x1, cpx1, cpx2, x2);\n    const bzy = buzzier_1.bzFunction(y1, cpy1, cpy2, y2);\n    const labelStartPos = {\n      x: bzx(0.01),\n      y: bzy(0.01)\n    };\n    const labelMiddlePos = {\n      x: bzx(0.5),\n      y: bzy(0.5)\n    };\n    const labelEndPos = {\n      x: bzx(0.99),\n      y: bzy(0.99)\n    };\n    const arrowEnd = {\n      x: bzx(1),\n      y: bzy(1)\n    };\n    setSt({\n      cx0,\n      cy0,\n      x1,\n      x2,\n      y1,\n      y2,\n      cw,\n      ch,\n      cpx1,\n      cpy1,\n      cpx2,\n      cpy2,\n      dx,\n      dy,\n      absDx,\n      absDy,\n      headOrient,\n      tailOrient,\n      labelStartPos,\n      labelMiddlePos,\n      labelEndPos,\n      arrowEnd,\n      excLeft,\n      excRight,\n      excUp,\n      excDown,\n      headOffset,\n      arrowHeadOffset,\n      arrowTailOffset\n    });\n  };\n\n  const fHeadSize = headSize * strokeWidth; //factored head size\n\n  const fTailSize = tailSize * strokeWidth; //factored head size\n\n  const xOffsetHead = st.x2 - st.arrowHeadOffset.x;\n  const yOffsetHead = st.y2 - st.arrowHeadOffset.y;\n  const xOffsetTail = st.x1 - st.arrowTailOffset.x;\n  const yOffsetTail = st.y1 - st.arrowTailOffset.y; // console.log(\"x1,x2,tailOrient\\n:\", st.x1, st.x2, st.tailOrient);\n\n  let arrowPath = `M ${st.x1} ${st.y1} C ${st.cpx1} ${st.cpy1}, ${st.cpx2} ${st.cpy2}, ${st.x2} ${st.y2} `;\n  if (path === \"straight\") arrowPath = `M ${st.x1} ${st.y1}  ${st.x2} ${st.y2}`;\n  if (path === \"grid\") arrowPath = `M ${st.x1} ${st.y1} L  ${st.cpx1} ${st.cpy1} L ${st.cpx2} ${st.cpy2} L  ${st.x2} ${st.y2}`;\n  return react_1.default.createElement(\"div\", Object.assign({}, divContainerProps, {\n    style: Object.assign({\n      position: \"absolute\"\n    }, divContainerStyle)\n  }, extraProps), react_1.default.createElement(\"svg\", Object.assign({\n    ref: selfRef,\n    width: st.cw,\n    height: st.ch,\n    style: Object.assign({\n      position: \"absolute\",\n      left: st.cx0,\n      top: st.cy0,\n      pointerEvents: \"none\",\n      border: _debug ? \"1px dashed yellow\" : null\n    }, SVGcanvasStyle),\n    overflow: \"auto\"\n  }, SVGcanvasProps), _debug ? react_1.default.createElement(react_1.default.Fragment, null, react_1.default.createElement(\"circle\", {\n    r: \"5\",\n    cx: st.cpx1,\n    cy: st.cpy1,\n    fill: \"green\"\n  }), react_1.default.createElement(\"circle\", {\n    r: \"5\",\n    cx: st.cpx2,\n    cy: st.cpy2,\n    fill: \"blue\"\n  }), react_1.default.createElement(\"rect\", {\n    x: st.excLeft,\n    y: st.excUp,\n    width: st.absDx,\n    height: st.absDy,\n    fill: \"none\",\n    stroke: \"pink\",\n    strokeWidth: \"2px\"\n  })) : null, showTail ? react_1.default.createElement(\"path\", Object.assign({\n    d: `M 0 0 L ${fTailSize} ${fTailSize / 2} L 0 ${fTailSize} L ${fTailSize / 4} ${fTailSize / 2} z`,\n    fill: tailColor,\n    pointerEvents: \"all\",\n    transform: `translate(${xOffsetTail},${yOffsetTail}) rotate(${st.tailOrient})`\n  }, passProps, arrowTailProps)) : null, react_1.default.createElement(\"path\", Object.assign({\n    d: arrowPath,\n    stroke: lineColor,\n    strokeDasharray: `${dashStroke} ${dashNone}`,\n    strokeWidth: strokeWidth,\n    fill: \"transparent\",\n    pointerEvents: \"visibleStroke\"\n  }, passProps, arrowBodyProps), animationSpeed ? react_1.default.createElement(\"animate\", {\n    attributeName: \"stroke-dashoffset\",\n    values: `${dashoffset * animationDirection};0`,\n    dur: `${1 / animationSpeed}s`,\n    repeatCount: \"indefinite\"\n  }) : null), showHead ? react_1.default.createElement(\"path\", Object.assign({\n    d: `M 0 0 L ${fHeadSize} ${fHeadSize / 2} L 0 ${fHeadSize} L ${fHeadSize / 4} ${fHeadSize / 2} z`,\n    fill: headColor,\n    pointerEvents: \"all\",\n    transform: `translate(${xOffsetHead},${yOffsetHead}) rotate(${st.headOrient})`\n  }, passProps, arrowHeadProps)) : null), labelStart ? react_1.default.createElement(\"div\", {\n    style: {\n      transform: st.dx < 0 ? \"translate(-100% , -50%)\" : \"translate(-0% , -50%)\",\n      width: \"max-content\",\n      position: \"absolute\",\n      left: st.cx0 + st.labelStartPos.x,\n      top: st.cy0 + st.labelStartPos.y - strokeWidth - 5\n    }\n  }, labelStart) : null, labelMiddle ? react_1.default.createElement(\"div\", {\n    style: {\n      display: \"table\",\n      width: \"max-content\",\n      transform: \"translate(-50% , -50%)\",\n      position: \"absolute\",\n      left: st.cx0 + st.labelMiddlePos.x,\n      top: st.cy0 + st.labelMiddlePos.y\n    }\n  }, labelMiddle) : null, labelEnd ? react_1.default.createElement(\"div\", {\n    style: {\n      transform: st.dx > 0 ? \"translate(-100% , -50%)\" : \"translate(-0% , -50%)\",\n      width: \"max-content\",\n      position: \"absolute\",\n      left: st.cx0 + st.labelEndPos.x,\n      top: st.cy0 + st.labelEndPos.y + strokeWidth + 5\n    }\n  }, labelEnd) : null);\n}; //////////////////////////////\n// propTypes\n\n\nconst pAnchorPositionType = prop_types_1.default.oneOf([\"middle\", \"left\", \"right\", \"top\", \"bottom\", \"auto\"]);\nconst pAnchorCustomPositionType = prop_types_1.default.exact({\n  position: pAnchorPositionType.isRequired,\n  offset: prop_types_1.default.shape({\n    rightness: prop_types_1.default.number,\n    bottomness: prop_types_1.default.number\n  }).isRequired\n});\n\nconst _pAnchorType = prop_types_1.default.oneOfType([pAnchorPositionType, pAnchorCustomPositionType]);\n\nconst pAnchorType = prop_types_1.default.oneOfType([_pAnchorType, prop_types_1.default.arrayOf(_pAnchorType)]);\nconst pRefType = prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.exact({\n  current: prop_types_1.default.instanceOf(Element)\n})]);\n\nconst _pLabelType = prop_types_1.default.oneOfType([prop_types_1.default.element, prop_types_1.default.string]);\n\nconst pLabelsType = prop_types_1.default.exact({\n  start: _pLabelType,\n  middle: _pLabelType,\n  end: _pLabelType\n});\nXarrow.propTypes = {\n  start: pRefType.isRequired,\n  end: pRefType.isRequired,\n  startAnchor: pAnchorType,\n  endAnchor: pAnchorType,\n  label: prop_types_1.default.oneOfType([_pLabelType, pLabelsType]),\n  color: prop_types_1.default.string,\n  lineColor: prop_types_1.default.string,\n  showHead: prop_types_1.default.bool,\n  headColor: prop_types_1.default.string,\n  headSize: prop_types_1.default.number,\n  tailSize: prop_types_1.default.number,\n  tailColor: prop_types_1.default.string,\n  strokeWidth: prop_types_1.default.number,\n  showTail: prop_types_1.default.bool,\n  path: prop_types_1.default.oneOf([\"smooth\", \"grid\", \"straight\"]),\n  curveness: prop_types_1.default.number,\n  dashness: prop_types_1.default.oneOfType([prop_types_1.default.bool, prop_types_1.default.object]),\n  passProps: prop_types_1.default.object,\n  arrowBodyProps: prop_types_1.default.object,\n  arrowHeadProps: prop_types_1.default.object,\n  arrowTailProps: prop_types_1.default.object,\n  SVGcanvasProps: prop_types_1.default.object,\n  divContainerProps: prop_types_1.default.object,\n  _extendSVGcanvas: prop_types_1.default.number,\n  _debug: prop_types_1.default.bool,\n  _cpx1Offset: prop_types_1.default.number,\n  _cpy1Offset: prop_types_1.default.number,\n  _cpx2Offset: prop_types_1.default.number,\n  _cpy2Offset: prop_types_1.default.number\n};\nXarrow.defaultProps = {\n  startAnchor: \"auto\",\n  endAnchor: \"auto\",\n  label: null,\n  color: \"CornflowerBlue\",\n  lineColor: null,\n  headColor: null,\n  tailColor: null,\n  strokeWidth: 4,\n  showHead: true,\n  headSize: 6,\n  showTail: false,\n  tailSize: 6,\n  path: \"smooth\",\n  curveness: 0.8,\n  dashness: false,\n  passProps: {},\n  arrowBodyProps: {},\n  arrowHeadProps: {},\n  arrowTailProps: {},\n  SVGcanvasProps: {},\n  divContainerProps: {},\n  _extendSVGcanvas: 0,\n  _debug: false,\n  _cpx1Offset: 0,\n  _cpy1Offset: 0,\n  _cpx2Offset: 0,\n  _cpy2Offset: 0\n};\nexports.default = Xarrow;","map":{"version":3,"sources":["../src/index.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nvar __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst react_1 = __importStar(require(\"react\"));\r\nconst lodash_isequal_1 = __importDefault(require(\"lodash.isequal\"));\r\nconst lodash_pick_1 = __importDefault(require(\"lodash.pick\"));\r\nconst utils_1 = require(\"./utils\");\r\nconst prop_types_1 = __importDefault(require(\"prop-types\"));\r\nconst buzzier_1 = require(\"./utils/buzzier\");\r\nconst anchors_1 = require(\"./utils/anchors\");\r\nconst Xarrow = (props) => {\r\n    let { startAnchor, endAnchor, label, color, lineColor, headColor, strokeWidth, showHead, headSize, showTail, tailColor, tailSize, path, curveness, dashness, passProps, SVGcanvasProps, arrowBodyProps, arrowHeadProps, arrowTailProps, divContainerProps, SVGcanvasStyle, divContainerStyle, _extendSVGcanvas, _debug, _cpx1Offset, _cpy1Offset, _cpx2Offset, _cpy2Offset } = props, extraProps = __rest(props, [\"startAnchor\", \"endAnchor\", \"label\", \"color\", \"lineColor\", \"headColor\", \"strokeWidth\", \"showHead\", \"headSize\", \"showTail\", \"tailColor\", \"tailSize\", \"path\", \"curveness\", \"dashness\", \"passProps\", \"SVGcanvasProps\", \"arrowBodyProps\", \"arrowHeadProps\", \"arrowTailProps\", \"divContainerProps\", \"SVGcanvasStyle\", \"divContainerStyle\", \"_extendSVGcanvas\", \"_debug\", \"_cpx1Offset\", \"_cpy1Offset\", \"_cpx2Offset\", \"_cpy2Offset\"]);\r\n    const selfRef = react_1.useRef(null);\r\n    const [anchorsRefs, setAnchorsRefs] = react_1.useState({ start: null, end: null });\r\n    const [prevPosState, setPrevPosState] = react_1.useState(null);\r\n    const [prevProps, setPrevProps] = react_1.useState(null);\r\n    /**\r\n     * determine if an update is needed and update if so.\r\n     * update is needed if one of the connected elements position was changed since last render, or if the ref to one\r\n     * of the elements has changed(it points to a different element).\r\n     */\r\n    const updateIfNeeded = () => {\r\n        // check if anchors refs changed\r\n        const start = utils_1.getElementByPropGiven(props.start);\r\n        const end = utils_1.getElementByPropGiven(props.end);\r\n        // in case one of the elements does not mounted skip any update\r\n        if (start == null || end == null)\r\n            return;\r\n        // if anchors changed re-set them\r\n        if (!lodash_isequal_1.default(anchorsRefs, { start, end })) {\r\n            initAnchorsRefs();\r\n        }\r\n        else if (!lodash_isequal_1.default(props, prevProps)) {\r\n            //first check if any properties changed\r\n            if (prevProps) {\r\n                initProps();\r\n                let posState = getAnchorsPos();\r\n                setPrevPosState(posState);\r\n                updatePosition(posState);\r\n            }\r\n        }\r\n        else {\r\n            //if the properties did not changed - update position if needed\r\n            let posState = getAnchorsPos();\r\n            if (!lodash_isequal_1.default(prevPosState, posState)) {\r\n                setPrevPosState(posState);\r\n                updatePosition(posState);\r\n            }\r\n        }\r\n    };\r\n    const initAnchorsRefs = () => {\r\n        const start = utils_1.getElementByPropGiven(props.start);\r\n        const end = utils_1.getElementByPropGiven(props.end);\r\n        setAnchorsRefs({ start, end });\r\n    };\r\n    const initProps = () => {\r\n        setPrevProps(props);\r\n    };\r\n    const monitorDOMchanges = () => {\r\n        window.addEventListener(\"resize\", updateIfNeeded);\r\n    };\r\n    const cleanMonitorDOMchanges = () => {\r\n        window.removeEventListener(\"resize\", updateIfNeeded);\r\n    };\r\n    react_1.useEffect(() => {\r\n        // console.log(\"xarrow mounted\");\r\n        initProps();\r\n        initAnchorsRefs();\r\n        monitorDOMchanges();\r\n        return () => {\r\n            cleanMonitorDOMchanges();\r\n        };\r\n    }, []);\r\n    react_1.useLayoutEffect(() => {\r\n        // console.log(\"xarrow rendered!\");\r\n        updateIfNeeded();\r\n    });\r\n    const [st, setSt] = react_1.useState({\r\n        //initial state\r\n        cx0: 0,\r\n        cy0: 0,\r\n        cw: 0,\r\n        ch: 0,\r\n        x1: 0,\r\n        y1: 0,\r\n        x2: 0,\r\n        y2: 0,\r\n        dx: 0,\r\n        dy: 0,\r\n        absDx: 0,\r\n        absDy: 0,\r\n        cpx1: 0,\r\n        cpy1: 0,\r\n        cpx2: 0,\r\n        cpy2: 0,\r\n        headOrient: 0,\r\n        tailOrient: 0,\r\n        labelStartPos: { x: 0, y: 0 },\r\n        labelMiddlePos: { x: 0, y: 0 },\r\n        labelEndPos: { x: 0, y: 0 },\r\n        arrowEnd: { x: 0, y: 0 },\r\n        arrowHeadOffset: { x: 0, y: 0 },\r\n        arrowTailOffset: { x: 0, y: 0 },\r\n        headOffset: 0,\r\n        excRight: 0,\r\n        excLeft: 0,\r\n        excUp: 0,\r\n        excDown: 0,\r\n    });\r\n    headSize = Number(headSize);\r\n    strokeWidth = Number(strokeWidth);\r\n    headColor = headColor ? headColor : color;\r\n    tailColor = tailColor ? tailColor : color;\r\n    lineColor = lineColor ? lineColor : color;\r\n    let dashStroke = 0, dashNone = 0, animationSpeed, animationDirection = 1;\r\n    if (dashness) {\r\n        if (typeof dashness === \"object\") {\r\n            dashStroke = dashness.strokeLen\r\n                ? Number(dashness.strokeLen)\r\n                : Number(strokeWidth) * 2;\r\n            dashNone = dashness.strokeLen\r\n                ? Number(dashness.nonStrokeLen)\r\n                : Number(strokeWidth);\r\n            animationSpeed = dashness.animation ? Number(dashness.animation) : null;\r\n        }\r\n        else if (typeof dashness === \"boolean\") {\r\n            dashStroke = Number(strokeWidth) * 2;\r\n            dashNone = Number(strokeWidth);\r\n            animationSpeed = null;\r\n        }\r\n    }\r\n    let dashoffset = dashStroke + dashNone;\r\n    if (animationSpeed < 0) {\r\n        animationSpeed *= -1;\r\n        animationDirection = -1;\r\n    }\r\n    let labelStart = null, labelMiddle = null, labelEnd = null;\r\n    if (label) {\r\n        if (typeof label === \"string\" || \"type\" in label)\r\n            labelMiddle = label;\r\n        else if ([\"start\", \"middle\", \"end\"].some((key) => key in label)) {\r\n            label = label;\r\n            ({ start: labelStart, middle: labelMiddle, end: labelEnd } = label);\r\n        }\r\n    }\r\n    const getSelfPos = () => {\r\n        let { left: xarrowElemX, top: xarrowElemY, } = selfRef.current.getBoundingClientRect();\r\n        let xarrowStyle = getComputedStyle(selfRef.current);\r\n        let xarrowStyleLeft = Number(xarrowStyle.left.slice(0, -2));\r\n        let xarrowStyleTop = Number(xarrowStyle.top.slice(0, -2));\r\n        return {\r\n            x: xarrowElemX - xarrowStyleLeft,\r\n            y: xarrowElemY - xarrowStyleTop,\r\n        };\r\n    };\r\n    const getAnchorsPos = () => {\r\n        let s = anchorsRefs.start.getBoundingClientRect();\r\n        let e = anchorsRefs.end.getBoundingClientRect();\r\n        return {\r\n            start: {\r\n                x: s.left,\r\n                y: s.top,\r\n                right: s.right,\r\n                bottom: s.bottom,\r\n            },\r\n            end: {\r\n                x: e.left,\r\n                y: e.top,\r\n                right: e.right,\r\n                bottom: e.bottom,\r\n            },\r\n        };\r\n    };\r\n    /**\r\n     * The Main logic of path calculation for the arrow.\r\n     * calculate new path and adjust canvas based on given properties.\r\n     * */\r\n    const updatePosition = (positions) => {\r\n        let { start: sPos } = positions;\r\n        let { end: ePos } = positions;\r\n        let headOrient = 0;\r\n        let tailOrient = 0;\r\n        // convert startAnchor and endAnchor to list of objects represents allowed anchors.\r\n        let startPointsObj = anchors_1.prepareAnchorLines(startAnchor, sPos);\r\n        let endPointsObj = anchors_1.prepareAnchorLines(endAnchor, ePos);\r\n        // choose the smallest path for 2 points from these possibilities.\r\n        let { startPointObj, endPointObj } = anchors_1.getShortestLine(startPointsObj, endPointsObj);\r\n        let startAnchorPosition = startPointObj.anchorPosition, endAnchorPosition = endPointObj.anchorPosition;\r\n        let startPoint = lodash_pick_1.default(startPointObj, [\"x\", \"y\"]), endPoint = lodash_pick_1.default(endPointObj, [\"x\", \"y\"]);\r\n        let xarrowElemPos = getSelfPos();\r\n        let cx0 = Math.min(startPoint.x, endPoint.x) - xarrowElemPos.x;\r\n        let cy0 = Math.min(startPoint.y, endPoint.y) - xarrowElemPos.y;\r\n        let dx = endPoint.x - startPoint.x;\r\n        let dy = endPoint.y - startPoint.y;\r\n        let absDx = Math.abs(endPoint.x - startPoint.x);\r\n        let absDy = Math.abs(endPoint.y - startPoint.y);\r\n        let xSign = dx > 0 ? 1 : -1;\r\n        let ySign = dy > 0 ? 1 : -1;\r\n        let headOffset = ((headSize * 3) / 4) * strokeWidth;\r\n        let tailOffset = ((tailSize * 3) / 4) * strokeWidth;\r\n        let cu = Number(curveness);\r\n        if (path === \"straight\") {\r\n            cu = 0;\r\n            path = \"smooth\";\r\n        }\r\n        let biggerSide = headSize > tailSize ? headSize : tailSize;\r\n        let calc = strokeWidth + (strokeWidth * biggerSide) / 2;\r\n        let excRight = calc;\r\n        let excLeft = calc;\r\n        let excUp = calc;\r\n        let excDown = calc;\r\n        excLeft += Number(_extendSVGcanvas);\r\n        excRight += Number(_extendSVGcanvas);\r\n        excUp += Number(_extendSVGcanvas);\r\n        excDown += Number(_extendSVGcanvas);\r\n        ////////////////////////////////////\r\n        // arrow point to point calculations\r\n        let x1 = 0, x2 = absDx, y1 = 0, y2 = absDy;\r\n        if (dx < 0)\r\n            [x1, x2] = [x2, x1];\r\n        if (dy < 0)\r\n            [y1, y2] = [y2, y1];\r\n        ////////////////////////////////////\r\n        // arrow curviness and arrowhead placement calculations\r\n        let xHeadOffset = 0;\r\n        let yHeadOffset = 0;\r\n        let xTailOffset = 0;\r\n        let yTailOffset = 0;\r\n        if (cu === 0) {\r\n            // in case of straight path\r\n            let headAngel = Math.atan(absDy / absDx);\r\n            if (showHead) {\r\n                x2 -= headOffset * xSign * Math.cos(headAngel);\r\n                y2 -= headOffset * ySign * Math.sin(headAngel);\r\n                // cpx2 -= headOffset * xSign * Math.cos(headAngel);\r\n                // cpy2 -= headOffset * ySign * Math.sin(headAngel);\r\n                headAngel *= ySign;\r\n                if (xSign < 0)\r\n                    headAngel = (Math.PI - headAngel * xSign) * xSign;\r\n                xHeadOffset =\r\n                    (Math.cos(headAngel) * headOffset) / 3 -\r\n                        (Math.sin(headAngel) * (headSize * strokeWidth)) / 2;\r\n                yHeadOffset =\r\n                    (Math.cos(headAngel) * (headSize * strokeWidth)) / 2 +\r\n                        (Math.sin(headAngel) * headOffset) / 3;\r\n                headOrient = (headAngel * 180) / Math.PI;\r\n            }\r\n            let tailAngel = Math.atan(absDy / absDx);\r\n            if (showTail) {\r\n                x1 += tailOffset * xSign * Math.cos(tailAngel);\r\n                y1 += tailOffset * ySign * Math.sin(tailAngel);\r\n                // cpx2 -= headOffset * xSign * Math.cos(headAngel);\r\n                // cpy2 -= headOffset * ySign * Math.sin(headAngel);\r\n                tailAngel *= -ySign;\r\n                if (xSign > 0)\r\n                    tailAngel = (Math.PI - tailAngel * xSign) * xSign;\r\n                xTailOffset =\r\n                    (Math.cos(tailAngel) * tailOffset) / 3 -\r\n                        (Math.sin(tailAngel) * (tailSize * strokeWidth)) / 2;\r\n                yTailOffset =\r\n                    (Math.cos(tailAngel) * (tailSize * strokeWidth)) / 2 +\r\n                        (Math.sin(tailAngel) * tailOffset) / 3;\r\n                tailOrient = (tailAngel * 180) / Math.PI;\r\n            }\r\n            //todo: add tail support\r\n        }\r\n        else {\r\n            // in case of smooth path\r\n            if (endAnchorPosition === \"middle\") {\r\n                // in case a middle anchor is chosen for endAnchor choose from which side to attach to the middle of the element\r\n                if (absDx > absDy) {\r\n                    endAnchorPosition = xSign ? \"left\" : \"right\";\r\n                }\r\n                else {\r\n                    endAnchorPosition = ySign ? \"top\" : \"bottom\";\r\n                }\r\n            }\r\n            if (showHead) {\r\n                if ([\"left\", \"right\"].includes(endAnchorPosition)) {\r\n                    x2 -= headOffset * xSign;\r\n                    // cpx2 -= headOffset * xSign * 2;\r\n                    // cpx1 += headOffset * xSign;\r\n                    xHeadOffset = (headOffset * xSign) / 3;\r\n                    yHeadOffset = (headSize * strokeWidth * xSign) / 2;\r\n                    if (endAnchorPosition === \"left\") {\r\n                        headOrient = 0;\r\n                        if (xSign < 0)\r\n                            headOrient += 180;\r\n                    }\r\n                    else {\r\n                        headOrient = 180;\r\n                        if (xSign > 0)\r\n                            headOrient += 180;\r\n                    }\r\n                }\r\n                else if ([\"top\", \"bottom\"].includes(endAnchorPosition)) {\r\n                    yHeadOffset = (headOffset * ySign) / 3;\r\n                    xHeadOffset = (headSize * strokeWidth * -ySign) / 2;\r\n                    y2 -= headOffset * ySign;\r\n                    // cpy1 += headOffset * ySign;\r\n                    // cpy2 -= headOffset * ySign;\r\n                    if (endAnchorPosition === \"top\") {\r\n                        headOrient = 270;\r\n                        if (ySign > 0)\r\n                            headOrient += 180;\r\n                    }\r\n                    else {\r\n                        headOrient = 90;\r\n                        if (ySign < 0)\r\n                            headOrient += 180;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (showTail && cu !== 0) {\r\n            if ([\"left\", \"right\"].includes(startAnchorPosition)) {\r\n                x1 += tailOffset * xSign;\r\n                xTailOffset = -(tailOffset * xSign) / 3;\r\n                yTailOffset = -(tailSize * strokeWidth * xSign) / 2;\r\n                if (startAnchorPosition === \"left\") {\r\n                    tailOrient = 180;\r\n                    if (xSign < 0)\r\n                        tailOrient += 180;\r\n                }\r\n                else {\r\n                    tailOrient = 0;\r\n                    if (xSign > 0)\r\n                        tailOrient += 180;\r\n                }\r\n            }\r\n            else if ([\"top\", \"bottom\"].includes(startAnchorPosition)) {\r\n                yTailOffset = -(tailOffset * ySign) / 3;\r\n                xTailOffset = -(tailSize * strokeWidth * -ySign) / 2;\r\n                y1 += tailOffset * ySign;\r\n                // cpy1 += tailOffset * ySign;\r\n                // cpy2 -= tailOffset * ySign;\r\n                if (startAnchorPosition === \"top\") {\r\n                    tailOrient = 90;\r\n                    if (ySign > 0)\r\n                        tailOrient += 180;\r\n                }\r\n                else {\r\n                    tailOrient = 270;\r\n                    if (ySign < 0)\r\n                        tailOrient += 180;\r\n                }\r\n            }\r\n        }\r\n        // if (endAnchorPosition == startAnchorPosition) headOrient += 180;\r\n        let arrowHeadOffset = { x: xHeadOffset, y: yHeadOffset };\r\n        let arrowTailOffset = { x: xTailOffset, y: yTailOffset };\r\n        let cpx1 = x1, cpy1 = y1, cpx2 = x2, cpy2 = y2;\r\n        let curvesPossibilities = {};\r\n        if (path === \"smooth\")\r\n            curvesPossibilities = {\r\n                hh: () => {\r\n                    //horizontal - from right to left or the opposite\r\n                    cpx1 += absDx * cu * xSign;\r\n                    cpx2 -= absDx * cu * xSign;\r\n                    // if (absDx < 2 * headOffset) {\r\n                    //   cpx1 += headOffset * xSign - absDx / 2;\r\n                    //   cpx2 -= headOffset * xSign * 2 - absDx;\r\n                    // }\r\n                    // cpx1 += headOffset * 2 * xSign;\r\n                    // cpx2 -= headOffset * 2 * xSign;\r\n                },\r\n                vv: () => {\r\n                    //vertical - from top to bottom or opposite\r\n                    cpy1 += absDy * cu * ySign;\r\n                    cpy2 -= absDy * cu * ySign;\r\n                    // cpy1 += headOffset * 2 * ySign;\r\n                    // cpy2 -= headOffset * 2 * ySign;\r\n                },\r\n                hv: () => {\r\n                    // start horizontally then vertically\r\n                    // from v side to h side\r\n                    cpx1 += absDx * cu * xSign;\r\n                    cpy2 -= absDy * cu * ySign;\r\n                },\r\n                vh: () => {\r\n                    // start vertically then horizontally\r\n                    // from h side to v side\r\n                    cpy1 += absDy * cu * ySign;\r\n                    cpx2 -= absDx * cu * xSign;\r\n                },\r\n            };\r\n        else if (path === \"grid\") {\r\n            curvesPossibilities = {\r\n                hh: () => {\r\n                    // cpx1 += (absDx * 0.5 - headOffset / 2) * xSign;\r\n                    // cpx2 -= (absDx * 0.5 - headOffset / 2) * xSign;\r\n                    cpx1 += absDx * 0.5 * xSign;\r\n                    cpx2 -= absDx * 0.5 * xSign;\r\n                    if (showHead) {\r\n                        cpx1 -= (headOffset / 2) * xSign;\r\n                        cpx2 += (headOffset / 2) * xSign;\r\n                    }\r\n                    if (showTail) {\r\n                        cpx1 -= (tailOffset / 2) * xSign;\r\n                        cpx2 += (tailOffset / 2) * xSign;\r\n                    }\r\n                },\r\n                vv: () => {\r\n                    // cpy1 += (absDy * 0.5 - headOffset / 2) * ySign;\r\n                    // cpy2 -= (absDy * 0.5 - headOffset / 2) * ySign;\r\n                    cpy1 += absDy * 0.5 * ySign;\r\n                    cpy2 -= absDy * 0.5 * ySign;\r\n                    if (showHead) {\r\n                        cpy1 -= (headOffset / 2) * ySign;\r\n                        cpy2 += (headOffset / 2) * ySign;\r\n                    }\r\n                    if (showTail) {\r\n                        cpy1 -= (tailOffset / 2) * ySign;\r\n                        cpy2 += (tailOffset / 2) * ySign;\r\n                    }\r\n                },\r\n                hv: () => {\r\n                    cpx1 = x2;\r\n                },\r\n                vh: () => {\r\n                    cpy1 = y2;\r\n                },\r\n            };\r\n        }\r\n        // smart select best curve for the current anchors\r\n        let selectedCurviness = \"\";\r\n        if ([\"left\", \"right\"].includes(startAnchorPosition))\r\n            selectedCurviness += \"h\";\r\n        else if ([\"bottom\", \"top\"].includes(startAnchorPosition))\r\n            selectedCurviness += \"v\";\r\n        else if (startAnchorPosition === \"middle\")\r\n            selectedCurviness += \"m\";\r\n        if ([\"left\", \"right\"].includes(endAnchorPosition))\r\n            selectedCurviness += \"h\";\r\n        else if ([\"bottom\", \"top\"].includes(endAnchorPosition))\r\n            selectedCurviness += \"v\";\r\n        else if (endAnchorPosition === \"middle\")\r\n            selectedCurviness += \"m\";\r\n        if (absDx > absDy)\r\n            selectedCurviness = selectedCurviness.replace(/m/g, \"h\");\r\n        else\r\n            selectedCurviness = selectedCurviness.replace(/m/g, \"v\");\r\n        curvesPossibilities[selectedCurviness]();\r\n        cpx1 += _cpx1Offset;\r\n        cpy1 += _cpy1Offset;\r\n        cpx2 += _cpx2Offset;\r\n        cpy2 += _cpy2Offset;\r\n        ////////////////////////////////////\r\n        // canvas smart size adjustments\r\n        const [xSol1, xSol2] = buzzier_1.buzzierMinSols(x1, cpx1, cpx2, x2);\r\n        const [ySol1, ySol2] = buzzier_1.buzzierMinSols(y1, cpy1, cpy2, y2);\r\n        if (xSol1 < 0)\r\n            excLeft += -xSol1;\r\n        if (xSol2 > absDx)\r\n            excRight += xSol2 - absDx;\r\n        if (ySol1 < 0)\r\n            excUp += -ySol1;\r\n        if (ySol2 > absDy)\r\n            excDown += ySol2 - absDy;\r\n        if (path === \"grid\") {\r\n            excLeft += calc;\r\n            excRight += calc;\r\n            excUp += calc;\r\n            excDown += calc;\r\n        }\r\n        x1 += excLeft;\r\n        x2 += excLeft;\r\n        y1 += excUp;\r\n        y2 += excUp;\r\n        cpx1 += excLeft;\r\n        cpx2 += excLeft;\r\n        cpy1 += excUp;\r\n        cpy2 += excUp;\r\n        const cw = absDx + excLeft + excRight, ch = absDy + excUp + excDown;\r\n        cx0 -= excLeft;\r\n        cy0 -= excUp;\r\n        //labels\r\n        const bzx = buzzier_1.bzFunction(x1, cpx1, cpx2, x2);\r\n        const bzy = buzzier_1.bzFunction(y1, cpy1, cpy2, y2);\r\n        const labelStartPos = { x: bzx(0.01), y: bzy(0.01) };\r\n        const labelMiddlePos = { x: bzx(0.5), y: bzy(0.5) };\r\n        const labelEndPos = { x: bzx(0.99), y: bzy(0.99) };\r\n        const arrowEnd = { x: bzx(1), y: bzy(1) };\r\n        setSt({\r\n            cx0,\r\n            cy0,\r\n            x1,\r\n            x2,\r\n            y1,\r\n            y2,\r\n            cw,\r\n            ch,\r\n            cpx1,\r\n            cpy1,\r\n            cpx2,\r\n            cpy2,\r\n            dx,\r\n            dy,\r\n            absDx,\r\n            absDy,\r\n            headOrient,\r\n            tailOrient,\r\n            labelStartPos,\r\n            labelMiddlePos,\r\n            labelEndPos,\r\n            arrowEnd,\r\n            excLeft,\r\n            excRight,\r\n            excUp,\r\n            excDown,\r\n            headOffset,\r\n            arrowHeadOffset,\r\n            arrowTailOffset,\r\n        });\r\n    };\r\n    const fHeadSize = headSize * strokeWidth; //factored head size\r\n    const fTailSize = tailSize * strokeWidth; //factored head size\r\n    const xOffsetHead = st.x2 - st.arrowHeadOffset.x;\r\n    const yOffsetHead = st.y2 - st.arrowHeadOffset.y;\r\n    const xOffsetTail = st.x1 - st.arrowTailOffset.x;\r\n    const yOffsetTail = st.y1 - st.arrowTailOffset.y;\r\n    // console.log(\"x1,x2,tailOrient\\n:\", st.x1, st.x2, st.tailOrient);\r\n    let arrowPath = `M ${st.x1} ${st.y1} C ${st.cpx1} ${st.cpy1}, ${st.cpx2} ${st.cpy2}, ${st.x2} ${st.y2} `;\r\n    if (path === \"straight\")\r\n        arrowPath = `M ${st.x1} ${st.y1}  ${st.x2} ${st.y2}`;\r\n    if (path === \"grid\")\r\n        arrowPath = `M ${st.x1} ${st.y1} L  ${st.cpx1} ${st.cpy1} L ${st.cpx2} ${st.cpy2} L  ${st.x2} ${st.y2}`;\r\n    return (react_1.default.createElement(\"div\", Object.assign({}, divContainerProps, { style: Object.assign({ position: \"absolute\" }, divContainerStyle) }, extraProps),\r\n        react_1.default.createElement(\"svg\", Object.assign({ ref: selfRef, width: st.cw, height: st.ch, style: Object.assign({ position: \"absolute\", left: st.cx0, top: st.cy0, pointerEvents: \"none\", border: _debug ? \"1px dashed yellow\" : null }, SVGcanvasStyle), overflow: \"auto\" }, SVGcanvasProps),\r\n            _debug ? (react_1.default.createElement(react_1.default.Fragment, null,\r\n                react_1.default.createElement(\"circle\", { r: \"5\", cx: st.cpx1, cy: st.cpy1, fill: \"green\" }),\r\n                react_1.default.createElement(\"circle\", { r: \"5\", cx: st.cpx2, cy: st.cpy2, fill: \"blue\" }),\r\n                react_1.default.createElement(\"rect\", { x: st.excLeft, y: st.excUp, width: st.absDx, height: st.absDy, fill: \"none\", stroke: \"pink\", strokeWidth: \"2px\" }))) : null,\r\n            showTail ? (react_1.default.createElement(\"path\", Object.assign({ d: `M 0 0 L ${fTailSize} ${fTailSize / 2} L 0 ${fTailSize} L ${fTailSize / 4} ${fTailSize / 2} z`, fill: tailColor, pointerEvents: \"all\", transform: `translate(${xOffsetTail},${yOffsetTail}) rotate(${st.tailOrient})` }, passProps, arrowTailProps))) : null,\r\n            react_1.default.createElement(\"path\", Object.assign({ d: arrowPath, stroke: lineColor, strokeDasharray: `${dashStroke} ${dashNone}`, strokeWidth: strokeWidth, fill: \"transparent\", pointerEvents: \"visibleStroke\" }, passProps, arrowBodyProps), animationSpeed ? (react_1.default.createElement(\"animate\", { attributeName: \"stroke-dashoffset\", values: `${dashoffset * animationDirection};0`, dur: `${1 / animationSpeed}s`, repeatCount: \"indefinite\" })) : null),\r\n            showHead ? (react_1.default.createElement(\"path\", Object.assign({ d: `M 0 0 L ${fHeadSize} ${fHeadSize / 2} L 0 ${fHeadSize} L ${fHeadSize / 4} ${fHeadSize / 2} z`, fill: headColor, pointerEvents: \"all\", transform: `translate(${xOffsetHead},${yOffsetHead}) rotate(${st.headOrient})` }, passProps, arrowHeadProps))) : null),\r\n        labelStart ? (react_1.default.createElement(\"div\", { style: {\r\n                transform: st.dx < 0 ? \"translate(-100% , -50%)\" : \"translate(-0% , -50%)\",\r\n                width: \"max-content\",\r\n                position: \"absolute\",\r\n                left: st.cx0 + st.labelStartPos.x,\r\n                top: st.cy0 + st.labelStartPos.y - strokeWidth - 5,\r\n            } }, labelStart)) : null,\r\n        labelMiddle ? (react_1.default.createElement(\"div\", { style: {\r\n                display: \"table\",\r\n                width: \"max-content\",\r\n                transform: \"translate(-50% , -50%)\",\r\n                position: \"absolute\",\r\n                left: st.cx0 + st.labelMiddlePos.x,\r\n                top: st.cy0 + st.labelMiddlePos.y,\r\n            } }, labelMiddle)) : null,\r\n        labelEnd ? (react_1.default.createElement(\"div\", { style: {\r\n                transform: st.dx > 0 ? \"translate(-100% , -50%)\" : \"translate(-0% , -50%)\",\r\n                width: \"max-content\",\r\n                position: \"absolute\",\r\n                left: st.cx0 + st.labelEndPos.x,\r\n                top: st.cy0 + st.labelEndPos.y + strokeWidth + 5,\r\n            } }, labelEnd)) : null));\r\n};\r\n//////////////////////////////\r\n// propTypes\r\nconst pAnchorPositionType = prop_types_1.default.oneOf([\r\n    \"middle\",\r\n    \"left\",\r\n    \"right\",\r\n    \"top\",\r\n    \"bottom\",\r\n    \"auto\",\r\n]);\r\nconst pAnchorCustomPositionType = prop_types_1.default.exact({\r\n    position: pAnchorPositionType.isRequired,\r\n    offset: prop_types_1.default.shape({\r\n        rightness: prop_types_1.default.number,\r\n        bottomness: prop_types_1.default.number,\r\n    }).isRequired,\r\n});\r\nconst _pAnchorType = prop_types_1.default.oneOfType([\r\n    pAnchorPositionType,\r\n    pAnchorCustomPositionType,\r\n]);\r\nconst pAnchorType = prop_types_1.default.oneOfType([_pAnchorType, prop_types_1.default.arrayOf(_pAnchorType)]);\r\nconst pRefType = prop_types_1.default.oneOfType([\r\n    prop_types_1.default.string,\r\n    prop_types_1.default.exact({ current: prop_types_1.default.instanceOf(Element) }),\r\n]);\r\nconst _pLabelType = prop_types_1.default.oneOfType([prop_types_1.default.element, prop_types_1.default.string]);\r\nconst pLabelsType = prop_types_1.default.exact({\r\n    start: _pLabelType,\r\n    middle: _pLabelType,\r\n    end: _pLabelType,\r\n});\r\nXarrow.propTypes = {\r\n    start: pRefType.isRequired,\r\n    end: pRefType.isRequired,\r\n    startAnchor: pAnchorType,\r\n    endAnchor: pAnchorType,\r\n    label: prop_types_1.default.oneOfType([_pLabelType, pLabelsType]),\r\n    color: prop_types_1.default.string,\r\n    lineColor: prop_types_1.default.string,\r\n    showHead: prop_types_1.default.bool,\r\n    headColor: prop_types_1.default.string,\r\n    headSize: prop_types_1.default.number,\r\n    tailSize: prop_types_1.default.number,\r\n    tailColor: prop_types_1.default.string,\r\n    strokeWidth: prop_types_1.default.number,\r\n    showTail: prop_types_1.default.bool,\r\n    path: prop_types_1.default.oneOf([\"smooth\", \"grid\", \"straight\"]),\r\n    curveness: prop_types_1.default.number,\r\n    dashness: prop_types_1.default.oneOfType([prop_types_1.default.bool, prop_types_1.default.object]),\r\n    passProps: prop_types_1.default.object,\r\n    arrowBodyProps: prop_types_1.default.object,\r\n    arrowHeadProps: prop_types_1.default.object,\r\n    arrowTailProps: prop_types_1.default.object,\r\n    SVGcanvasProps: prop_types_1.default.object,\r\n    divContainerProps: prop_types_1.default.object,\r\n    _extendSVGcanvas: prop_types_1.default.number,\r\n    _debug: prop_types_1.default.bool,\r\n    _cpx1Offset: prop_types_1.default.number,\r\n    _cpy1Offset: prop_types_1.default.number,\r\n    _cpx2Offset: prop_types_1.default.number,\r\n    _cpy2Offset: prop_types_1.default.number,\r\n};\r\nXarrow.defaultProps = {\r\n    startAnchor: \"auto\",\r\n    endAnchor: \"auto\",\r\n    label: null,\r\n    color: \"CornflowerBlue\",\r\n    lineColor: null,\r\n    headColor: null,\r\n    tailColor: null,\r\n    strokeWidth: 4,\r\n    showHead: true,\r\n    headSize: 6,\r\n    showTail: false,\r\n    tailSize: 6,\r\n    path: \"smooth\",\r\n    curveness: 0.8,\r\n    dashness: false,\r\n    passProps: {},\r\n    arrowBodyProps: {},\r\n    arrowHeadProps: {},\r\n    arrowTailProps: {},\r\n    SVGcanvasProps: {},\r\n    divContainerProps: {},\r\n    _extendSVGcanvas: 0,\r\n    _debug: false,\r\n    _cpx1Offset: 0,\r\n    _cpy1Offset: 0,\r\n    _cpx2Offset: 0,\r\n    _cpy2Offset: 0,\r\n};\r\nexports.default = Xarrow;\r\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}