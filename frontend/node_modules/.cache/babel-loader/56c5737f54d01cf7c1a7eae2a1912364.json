{"ast":null,"code":"// Tarjan's algorithm (full recursive DFS traversal)\nconst topoSort = g => {\n  // stack of nodes to return in order of decreasing finish timed\n  const finished = []; // map of node to color (0 is undiscovered, 1 is discovered, 2 is finished)\n\n  const color = new Map();\n  let valid = true; // initialize color of each node to 0 (undiscovered)\n\n  g.adjList.forEach((values, node) => {\n    color.set(node, 0);\n  });\n  g.adjList.forEach((values, node) => {\n    // if undiscovered, visit node\n    if (color.get(node) === 0) {\n      if (!dfsVisit(g, node, color, finished)) {\n        valid = false;\n      }\n    }\n  }); // return nodes in decreasing order of finish times\n\n  return {\n    valid: valid,\n    res: finished.reverse()\n  };\n}; // DFS helper method\n\n\nfunction dfsVisit(g, node, color, finished) {\n  color.set(node, 1); // iterate through neighbors\n\n  const neighbors = g.adjList.get(node);\n  let valid = true;\n  neighbors.forEach(({\n    node: v,\n    weight\n  }) => {\n    // found back edge, which implies cycle exists so no valid topo sort\n    if (color.get(v) === 1) {\n      valid = false;\n    } // if node undiscovered and no cycles have been found, visit node\n\n\n    if (color.get(v) === 0) {\n      if (!dfsVisit(g, v, color, finished)) {\n        valid = false;\n      }\n    }\n  }); // finish node\n\n  color.set(node, 2); // push node to stack once finished\n\n  finished.push(node);\n  return valid;\n}\n\nexport default topoSort;","map":{"version":3,"sources":["/Users/jgchen/Desktop/Dev/graph-visualizer/src/algos/topoSort.js"],"names":["topoSort","g","finished","color","Map","valid","adjList","forEach","values","node","set","get","dfsVisit","res","reverse","neighbors","v","weight","push"],"mappings":"AAAA;AACA,MAAMA,QAAQ,GAAIC,CAAD,IAAO;AACvB;AACA,QAAMC,QAAQ,GAAG,EAAjB,CAFuB,CAGvB;;AACA,QAAMC,KAAK,GAAG,IAAIC,GAAJ,EAAd;AACA,MAAIC,KAAK,GAAG,IAAZ,CALuB,CAOvB;;AACAJ,EAAAA,CAAC,CAACK,OAAF,CAAUC,OAAV,CAAkB,CAACC,MAAD,EAASC,IAAT,KAAkB;AACnCN,IAAAA,KAAK,CAACO,GAAN,CAAUD,IAAV,EAAgB,CAAhB;AACA,GAFD;AAIAR,EAAAA,CAAC,CAACK,OAAF,CAAUC,OAAV,CAAkB,CAACC,MAAD,EAASC,IAAT,KAAkB;AACnC;AACA,QAAIN,KAAK,CAACQ,GAAN,CAAUF,IAAV,MAAoB,CAAxB,EAA2B;AAC1B,UAAI,CAACG,QAAQ,CAACX,CAAD,EAAIQ,IAAJ,EAAUN,KAAV,EAAiBD,QAAjB,CAAb,EAAyC;AACxCG,QAAAA,KAAK,GAAG,KAAR;AACA;AACD;AACD,GAPD,EAZuB,CAoBvB;;AACA,SAAO;AAAEA,IAAAA,KAAK,EAAEA,KAAT;AAAgBQ,IAAAA,GAAG,EAAEX,QAAQ,CAACY,OAAT;AAArB,GAAP;AACA,CAtBD,C,CAwBA;;;AACA,SAASF,QAAT,CAAkBX,CAAlB,EAAqBQ,IAArB,EAA2BN,KAA3B,EAAkCD,QAAlC,EAA4C;AAC3CC,EAAAA,KAAK,CAACO,GAAN,CAAUD,IAAV,EAAgB,CAAhB,EAD2C,CAE3C;;AACA,QAAMM,SAAS,GAAGd,CAAC,CAACK,OAAF,CAAUK,GAAV,CAAcF,IAAd,CAAlB;AACA,MAAIJ,KAAK,GAAG,IAAZ;AACAU,EAAAA,SAAS,CAACR,OAAV,CAAkB,CAAC;AAAEE,IAAAA,IAAI,EAAEO,CAAR;AAAWC,IAAAA;AAAX,GAAD,KAAyB;AAC1C;AACA,QAAId,KAAK,CAACQ,GAAN,CAAUK,CAAV,MAAiB,CAArB,EAAwB;AACvBX,MAAAA,KAAK,GAAG,KAAR;AACA,KAJyC,CAM1C;;;AACA,QAAIF,KAAK,CAACQ,GAAN,CAAUK,CAAV,MAAiB,CAArB,EAAwB;AACvB,UAAI,CAACJ,QAAQ,CAACX,CAAD,EAAIe,CAAJ,EAAOb,KAAP,EAAcD,QAAd,CAAb,EAAsC;AACrCG,QAAAA,KAAK,GAAG,KAAR;AACA;AACD;AACD,GAZD,EAL2C,CAmB3C;;AACAF,EAAAA,KAAK,CAACO,GAAN,CAAUD,IAAV,EAAgB,CAAhB,EApB2C,CAqB3C;;AACAP,EAAAA,QAAQ,CAACgB,IAAT,CAAcT,IAAd;AACA,SAAOJ,KAAP;AACA;;AAED,eAAeL,QAAf","sourcesContent":["// Tarjan's algorithm (full recursive DFS traversal)\nconst topoSort = (g) => {\n\t// stack of nodes to return in order of decreasing finish timed\n\tconst finished = [];\n\t// map of node to color (0 is undiscovered, 1 is discovered, 2 is finished)\n\tconst color = new Map();\n\tlet valid = true;\n\n\t// initialize color of each node to 0 (undiscovered)\n\tg.adjList.forEach((values, node) => {\n\t\tcolor.set(node, 0);\n\t});\n\n\tg.adjList.forEach((values, node) => {\n\t\t// if undiscovered, visit node\n\t\tif (color.get(node) === 0) {\n\t\t\tif (!dfsVisit(g, node, color, finished)) {\n\t\t\t\tvalid = false;\n\t\t\t}\n\t\t}\n\t});\n\t// return nodes in decreasing order of finish times\n\treturn { valid: valid, res: finished.reverse() };\n};\n\n// DFS helper method\nfunction dfsVisit(g, node, color, finished) {\n\tcolor.set(node, 1);\n\t// iterate through neighbors\n\tconst neighbors = g.adjList.get(node);\n\tlet valid = true;\n\tneighbors.forEach(({ node: v, weight }) => {\n\t\t// found back edge, which implies cycle exists so no valid topo sort\n\t\tif (color.get(v) === 1) {\n\t\t\tvalid = false;\n\t\t}\n\n\t\t// if node undiscovered and no cycles have been found, visit node\n\t\tif (color.get(v) === 0) {\n\t\t\tif (!dfsVisit(g, v, color, finished)) {\n\t\t\t\tvalid = false;\n\t\t\t}\n\t\t}\n\t});\n\n\t// finish node\n\tcolor.set(node, 2);\n\t// push node to stack once finished\n\tfinished.push(node);\n\treturn valid;\n}\n\nexport default topoSort;\n"]},"metadata":{},"sourceType":"module"}