{"ast":null,"code":"// start - node to start DFS from\n// only visits nodes reachable from start (NOT full traversal)\nconst dfs = (g, start) => {\n  // stack for iterative DFS\n  const stack = []; // array of nodes to return\n\n  const result = []; // set of discovered nodes\n\n  const discovered = new Set(); // initialize by adding start node\n\n  stack.push(start);\n\n  while (stack.length !== 0) {\n    // pop stack, look at node's neighbors\n    const curr = stack.pop();\n    const outneighbors = g.adjList.get(curr); // if we haven't seen this node, add the node\n\n    if (!discovered.has(curr)) {\n      result.push(curr);\n      discovered.add(curr);\n    } // add each neighbor of current node to stack\n\n\n    outneighbors.forEach(({\n      node,\n      weight\n    }) => {\n      if (!discovered.has(node)) {\n        stack.push(node);\n      }\n    });\n  }\n\n  return result;\n};\n\nexport default dfs;","map":{"version":3,"sources":["/Users/jgchen/Desktop/Dev/graph-visualizer/src/algos/dfs.js"],"names":["dfs","g","start","stack","result","discovered","Set","push","length","curr","pop","outneighbors","adjList","get","has","add","forEach","node","weight"],"mappings":"AAAA;AACA;AACA,MAAMA,GAAG,GAAG,CAACC,CAAD,EAAIC,KAAJ,KAAc;AACzB;AACA,QAAMC,KAAK,GAAG,EAAd,CAFyB,CAGzB;;AACA,QAAMC,MAAM,GAAG,EAAf,CAJyB,CAKzB;;AACA,QAAMC,UAAU,GAAG,IAAIC,GAAJ,EAAnB,CANyB,CAOzB;;AACAH,EAAAA,KAAK,CAACI,IAAN,CAAWL,KAAX;;AAEA,SAAOC,KAAK,CAACK,MAAN,KAAiB,CAAxB,EAA2B;AAC1B;AACA,UAAMC,IAAI,GAAGN,KAAK,CAACO,GAAN,EAAb;AACA,UAAMC,YAAY,GAAGV,CAAC,CAACW,OAAF,CAAUC,GAAV,CAAcJ,IAAd,CAArB,CAH0B,CAK1B;;AACA,QAAI,CAACJ,UAAU,CAACS,GAAX,CAAeL,IAAf,CAAL,EAA2B;AAC1BL,MAAAA,MAAM,CAACG,IAAP,CAAYE,IAAZ;AACAJ,MAAAA,UAAU,CAACU,GAAX,CAAeN,IAAf;AACA,KATyB,CAW1B;;;AACAE,IAAAA,YAAY,CAACK,OAAb,CAAqB,CAAC;AAAEC,MAAAA,IAAF;AAAQC,MAAAA;AAAR,KAAD,KAAsB;AAC1C,UAAI,CAACb,UAAU,CAACS,GAAX,CAAeG,IAAf,CAAL,EAA2B;AAC1Bd,QAAAA,KAAK,CAACI,IAAN,CAAWU,IAAX;AACA;AACD,KAJD;AAKA;;AAED,SAAOb,MAAP;AACA,CA9BD;;AAgCA,eAAeJ,GAAf","sourcesContent":["// start - node to start DFS from\n// only visits nodes reachable from start (NOT full traversal)\nconst dfs = (g, start) => {\n\t// stack for iterative DFS\n\tconst stack = [];\n\t// array of nodes to return\n\tconst result = [];\n\t// set of discovered nodes\n\tconst discovered = new Set();\n\t// initialize by adding start node\n\tstack.push(start);\n\n\twhile (stack.length !== 0) {\n\t\t// pop stack, look at node's neighbors\n\t\tconst curr = stack.pop();\n\t\tconst outneighbors = g.adjList.get(curr);\n\n\t\t// if we haven't seen this node, add the node\n\t\tif (!discovered.has(curr)) {\n\t\t\tresult.push(curr);\n\t\t\tdiscovered.add(curr);\n\t\t}\n\n\t\t// add each neighbor of current node to stack\n\t\toutneighbors.forEach(({ node, weight }) => {\n\t\t\tif (!discovered.has(node)) {\n\t\t\t\tstack.push(node);\n\t\t\t}\n\t\t});\n\t}\n\n\treturn result;\n};\n\nexport default dfs;\n"]},"metadata":{},"sourceType":"module"}